
#include "light.glh"

layout (binding = 20) uniform sampler2DShadow u_shadow_atlas;
layout (binding = 21) uniform sampler2D       u_shadow_atlas_normals;
layout (binding = 22) uniform sampler2D       u_shadow_atlas_single;

uniform float u_shadow_max_distance;

uniform float u_shadow_bias_constant;
uniform float u_shadow_bias_slope_scale;
uniform float u_shadow_bias_distance_scale;
uniform float u_shadow_bias_slope_power;
uniform float u_shadow_bias_scale;
uniform float u_shadow_bias_texel_size_mix;

uniform float u_csm_light_radius_uv;  // PCSS
uniform uint  u_csm_num_cascades;
uniform float u_csm_split_depth[MAX_CASCADES];
uniform vec2  u_csm_cascade_near_far[MAX_CASCADES];

vec2 shadow_atlas_texel_size;

const vec2 Poisson25[25] = vec2[](
    vec2(-0.978698,  -0.0884121),
    vec2(-0.841121,   0.521165),
    vec2(-0.71746,   -0.50322),
    vec2(-0.702933,   0.903134),
    vec2(-0.663198,   0.15482),
    vec2(-0.495102,  -0.232887),
    vec2(-0.364238,  -0.961791),
    vec2(-0.345866,  -0.564379),
    vec2(-0.325663,   0.64037),
    vec2(-0.182714,   0.321329),
    vec2(-0.142613,  -0.0227363),
    vec2(-0.0564287, -0.36729),
    vec2(-0.0185858,  0.918882),
    vec2( 0.0381787, -0.728996),
    vec2( 0.16599,    0.093112),
    vec2( 0.253639,   0.719535),
    vec2( 0.369549,  -0.655019),
    vec2( 0.423627,   0.429975),
    vec2( 0.530747,  -0.364971),
    vec2( 0.566027,  -0.940489),
    vec2( 0.639332,   0.0284127),
    vec2( 0.652089,   0.669668),
    vec2( 0.773797,   0.345012),
    vec2( 0.968871,   0.840449),
    vec2( 0.991882,  -0.657338)
);

const vec2 Poisson32[32] = vec2[](
    vec2(-0.975402,  -0.0711386),
    vec2(-0.920347,  -0.41142),
    vec2(-0.883908,   0.217872),
    vec2(-0.884518,   0.568041),
    vec2(-0.811945,   0.90521),
    vec2(-0.792474,  -0.779962),
    vec2(-0.614856,   0.386578),
    vec2(-0.580859,  -0.208777),
    vec2(-0.53795,    0.716666),
    vec2(-0.515427,   0.0899991),
    vec2(-0.454634,  -0.707938),
    vec2(-0.420942,   0.991272),
    vec2(-0.261147,   0.588488),
    vec2(-0.211219,   0.114841),
    vec2(-0.146336,  -0.259194),
    vec2(-0.139439,  -0.888668),
    vec2( 0.0116886,  0.326395),
    vec2( 0.0380566,  0.625477),
    vec2( 0.0625935, -0.50853),
    vec2( 0.125584,   0.0469069),
    vec2( 0.169469,  -0.997253),
    vec2( 0.320597,   0.291055),
    vec2( 0.359172,  -0.633717),
    vec2( 0.435713,  -0.250832),
    vec2( 0.507797,  -0.916562),
    vec2( 0.545763,   0.730216),
    vec2( 0.56859,    0.11655),
    vec2( 0.743156,  -0.505173),
    vec2( 0.736442,  -0.189734),
    vec2( 0.843562,   0.357036),
    vec2( 0.865413,   0.763726),
    vec2( 0.872005,  -0.927)
);


uint detectCubeFaceSlot(vec3 light_to_frag, ShadowSlotInfo slot_info, out mat4 view_proj, out vec4 rect, out float texel_size)
{
	// figure out which of the 6 cube faces is relevant

	// X-axis as initial assumption
	int major_axis = 0;
	float max_axis = abs(light_to_frag.x);
	vec3 abs_dir = abs(light_to_frag);

	if (abs_dir.y > max_axis)
	{
	    major_axis = 1;
	    max_axis = abs_dir.y;
	}
	if (abs_dir.z > max_axis)
	{
	    major_axis = 2;
	    max_axis = abs_dir.z;
	}

	// select projection and atlas rect for this face
	//   surprisingly, this ugliness is quite a bit faster than just view_proj[face]
	mat4 vp_0 = slot_info.view_proj[0];
	mat4 vp_1 = slot_info.view_proj[1];
	mat4 vp_2 = slot_info.view_proj[2];
	mat4 vp_3 = slot_info.view_proj[3];
	mat4 vp_4 = slot_info.view_proj[4];
	mat4 vp_5 = slot_info.view_proj[5];

	vec4 rect_0 = slot_info.atlas_rect[0];
	vec4 rect_1 = slot_info.atlas_rect[1];
	vec4 rect_2 = slot_info.atlas_rect[2];
	vec4 rect_3 = slot_info.atlas_rect[3];
	vec4 rect_4 = slot_info.atlas_rect[4];
	vec4 rect_5 = slot_info.atlas_rect[5];

	float texel_size_0 = slot_info.texel_size[0];
	float texel_size_1 = slot_info.texel_size[1];
	float texel_size_2 = slot_info.texel_size[2];
	float texel_size_3 = slot_info.texel_size[3];
	float texel_size_4 = slot_info.texel_size[4];
	float texel_size_5 = slot_info.texel_size[5];


	uint face;

	if (major_axis == 0)
	{
	    if(light_to_frag.x > 0) // +X
		{
			face = 0;
			view_proj = vp_0;
			rect = rect_0;
			texel_size = texel_size_0;
		}
		else  // -X
		{
			face = 1;
			view_proj = vp_1;
			rect = rect_1;
			texel_size = texel_size_1;
		}
	}
	else if (major_axis == 1)
	{
		if(light_to_frag.y > 0) // +Y
		{
			face = 2;
			view_proj = vp_2;
			rect = rect_2;
			texel_size = texel_size_2;
		}
		else  // -Y
		{
			face = 3;
			view_proj = vp_3;
			rect = rect_3;
			texel_size = texel_size_3;
		}
	}
	else
	{
	    if(light_to_frag.z > 0) // +Z
		{
			face = 4;
			view_proj = vp_4;
			rect = rect_4;
			texel_size = texel_size_4;
		}
		else  // -Z
		{
			face = 5;
			view_proj = vp_5;
			rect = rect_5;
			texel_size = texel_size_5;
		}
	}

	return face;
}

vec2 calculateShadowUV(vec3 uv_pos, vec4 rect, out vec4 rect_uv)
{
	// in:  face_uv  : position within the shadow map slot (i.e. a regular shadow map uv)
	// in:  rect     : slot square in atlas pixel-space; x,y & w,h
	// out: rect_uv  : slot square in atlas UV-space; x,y & w,h
	// out: atlas_uv : resulting UV into the (full) atlas

	// TODO: add 1-texl border around the rect
	//   this requires the shadow rendering to also do this (in renderShadowMaps())

	vec2 face_uv = uv_pos.xy;
	rect_uv = rect * vec4(shadow_atlas_texel_size, shadow_atlas_texel_size);
	return rect_uv.xy + face_uv * rect_uv.zw;
}

vec3 unpackNormal(vec2 f)
{
    // float z = sqrt(max(0, 1 - dot(f, f)));
    // return vec3(f, z);

    // octahedral encoding
    f = f * 2.0 - 1.0; // Back to [-1, 1]
    vec3 n = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = clamp(-n.z, 0.0, 1.0);
    n.xy -= sign(n.xy) * t;
    return normalize(n);
}

float sampleShadow(float camera_distance, float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max);

float computeBias(float normalized_depth, vec3 light_dir, vec2 normalv, float texel_radius);

float sampleShadow1(float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max);

float shadowVisibility(vec3 uv_pos, float camera_distance, GPULight light, vec4 slot_rect, float texel_size, float bias)
{
	float uv_depth = uv_pos.z;
	uv_depth += bias;

	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(uv_pos, slot_rect, rect_uv);

	vec2 uv_min = rect_uv.xy;
	vec2 uv_max = rect_uv.xy + rect_uv.zw - shadow_atlas_texel_size;
	return sampleShadow(camera_distance, uv_depth, atlas_uv, uv_min, uv_max);
}
/*
float pcssSearchRadiusUV(float z_world);
void pcssFindBlocker(vec2 uv_pos, float uv_depth, float bias, float radius, uint cascade_index, out float accum_blocker_depth, out float num_blockers);
float zClipToEye(float z, float near, float far);
float penumbraRadiusUV(float z_receiver, float z_blocker, float light_radius);
float projectToLightUV(float size_uv, float z_world);

float shadowVisibilityPCSS(vec2 uv_pos, float uv_depth, float depth_ls, GPULight light, vec4 rect, float texel_size, float bias, float light_radius)
{
	// 1: blocker search
	float accum_blocker_depth, num_blockers;
	float radius = pcssSearchRadiusUV(depth_ls);
	pcssFindBlocker(uv_pos, uv_depth, bias, radius, cascade_index, accum_blocker_depth, num_blockers);

	if(num_blockers == 0)
	    return 1;


	float near_plane = u_csm_cascade_near_far[cascade_index].x;
	float far_plane = u_csm_cascade_near_far[cascade_index].y;

	// 2: penumbra size
	float avg_blocker_depth    = accum_blocker_depth / num_blockers;
	float avg_blocker_depth_vs = zClipToEye(avg_blocker_depth, near_plane, far_plane);
	float penumbra_radius      = penumbraRadiusUV(uv_depth, avg_blocker_depth_vs, light_radius);
	float filter_radius        = projectToLightUV(penumbra_radius, z_vs, near_plane);

	return shadowVisibility(clip_pos, light, rect, texel_size, bias);
}

// Returns average blocker depth in the search region, as well as the number of found blockers.
// Blockers are defined as shadow-map samples between the surface point and the light.
void pcssFindBlocker(vec2     uv_pos,
	                float     uv_depth,
	                float     bias,
	                float     radius,
	                uint      cascade_index,
	                out float accum_blocker_depth,
					out float num_blockers)
{
	float correction_factor = 1;
	// NOTE: can the "blue noise" texture can be used here as well?
    vec2 random_angle = texture(s_random_angles, in_world_pos * correction_factor).xy;
    float angle_cos = random_angle.x;
    float angle_sin = random_angle.y;
    mat2 rendom_rotation = mat2(angle_xos, -angle_sin, angle_sin, angle_cos);

    accum_blocker_depth = 0;
    num_blockers        = 0;
    float biased_depth  = uv_depth - bias;

    for(int idx = 0; idx < u_blocker_search_samples; ++idx)
    {
        vec2 offset;

        if(u_blocker_search_samples == 25)
            offset = Poisson25[idx];
        else if(u_blocker_search_samples == 32)
            offset = Poisson32[idx];
        // else if(u_blocker_search_samples == 64)
        //     offset = Poisson64[idx];
        // else if(u_blocker_search_samples == 100)
        //     offset = Poisson100[idx];
        // else if(u_blocker_search_samples == 128)
        //     offset = Poisson128[idx];

        // add random rotation to the offset
        // offset = vec2(angle_cos * offset.x - angle_sin * offset.y,
        //               angle_sin * offset.x + angle_cos * offset.y);
        offset = offset * random_rotation;

        offset *= radius;
        vec2 sample_uv = pos_uv + offset;
        float shadow_map_depth = texture(u_shadow_atlas_single, vec3(sample_uv, cascade_index)).r;

        if(shadow_map_depth < biased_depth)
        {
            accum_blocker_depth += shadow_map_depth;
            num_blockers++;
        }
    }
}

float pcssSearchRadiusUV(float z_world)
{
    return light_radius * (z_world - light_near_plane) / z_world;
}

float zClipToEye(float z, float near, float far)
{
    return light_far_plane * light_near_plane / (light_far_plane - z * (light_far_plane - light_near_plane));
}

float penumbraRadiusUV(float z_receiver, float z_blocker, float light_radius)
{
    return light_radius * (z_receiver - z_blocker) / z_blocker;
}

float projectToLightUV(float size_uv, float z_world, float near_plane)
{
    return size_uv * near_plane / z_world;
}
*/
float computeReceiverPlaneDepthBias(vec3 pos_dx, vec3 pos_dy)
{
	vec2 receiver_bias;
    receiver_bias.x = pos_dy.y * pos_dx.z - pos_dx.y * pos_dy.z;
    receiver_bias.y = pos_dx.x * pos_dy.z - pos_dy.x * pos_dx.z;
    receiver_bias *= 1 / ((pos_dx.x * pos_dy.y) - (pos_dx.y * pos_dy.x));

	float sampling_error = 2 * dot(shadow_atlas_texel_size, abs(receiver_bias));
	return min(sampling_error, 0.01)*u_shadow_bias_slope_scale;
}

float computeSlopeBias(vec3 light_dir, vec3 normal)
{
	float angle = dot(normal, light_dir);
	angle = pow(angle, u_shadow_bias_slope_power);
	angle = clamp(angle, 0.0, 0.99);
	return (0.001 / angle) * u_shadow_bias_slope_scale;
}

float computeBias(float normalized_depth, vec3 light_dir, vec3 normal, float texel_size)
{
	// calculate shadow depth bias by various factors
	// bias by depth
	float bias = normalized_depth * u_shadow_bias_distance_scale;

	// bias based on surface normals
	// bias increases when the angle between normal and light_dir is steep.
	bias += computeSlopeBias(light_dir, normal);

	bias = clamp(bias, -0.05, 0.05) * u_shadow_bias_scale;

	bias *= mix(1, texel_size, u_shadow_bias_texel_size_mix);

	return bias + u_shadow_bias_constant;
}

float sampleShadow1(float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	// only sample within the slot
	atlas_uv = clamp(atlas_uv, uv_min, uv_max);
	return texture(u_shadow_atlas, vec3(atlas_uv, frag_depth));
}

float sampleShadow5(float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	// 5-point "kernel", X-shape

	vec2 uv;
	float shadow = 0;
	float sample_depth;

	// NOTE: UV is capped to stay withing the single shadow map slot (cube face)
	//   but strictly, the sampling should in those cases instead sample from the
	//   "spatial naighbour" slot. That is, however, quite complicated... :|

	// TODO: sample using sampler2DShadow for all samples,
	//   except near edges (1-2 texel margin), where sampler2D should be used.
	//   otherwise, sampler2DShadow will sample outside the slot square (commonly uses 2x2 texels)
#define SAMPLE(uv_offset, weight) \
	uv = atlas_uv + uv_offset*shadow_atlas_texel_size; \
	shadow += sampleShadow1(frag_depth, uv, uv_min, uv_max)*weight;

	// cheaper sampling: only center and four corners of the 3x3 box
	const float weights5[2] = { 0.4, 0.15 };  // total = 1
	// top corners
	SAMPLE(vec2(-1, -1), weights5[1]);
	SAMPLE(vec2( 1, -1), weights5[1]);
	// center
	SAMPLE(vec2( 0,  0), weights5[0]);
	// bottom corners
	SAMPLE(vec2(-1,  1), weights5[1]);
	SAMPLE(vec2( 1,  1), weights5[1]);

	return shadow;
}

float sampleShadow9(float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	// 3x3 gauss kernel

	// TODO: random sampling
	//    https://www.youtube.com/watch?v=NCptEJ1Uevg&t=380s
	//    https://www.youtube.com/watch?v=3FMONJ1O39U&t=850s
	//    or even demo 24 & 25

	vec2 uv;
	float shadow = 0;
	float sample_depth;

	// NOTE: UV is capped to stay withing the single shadow map slot (cube face)
	//   but strictly, the sampling should in those cases instead sample from the
	//   "spatial naighbour" slot. That is, however, quite complicated... :|

	// TODO: possible to increase the sample raidus depending on 'current_depth'
	//   i.e. to achieve more blurred shadow for more distant shadows

	// sample a 3x3 box around the sample
#define SAMPLE(uv_offset, weight) \
	uv = atlas_uv + uv_offset*shadow_atlas_texel_size; \
	shadow += sampleShadow1(frag_depth, uv, uv_min, uv_max)*weight;

  	// 3x3 gauss box
  	const float weights9[3] = { 0.25, 0.125, 0.0625 };  // total = 1
	// top row
	SAMPLE(vec2(-1, -1), weights9[2]);
	SAMPLE(vec2( 0, -1), weights9[1]);
	SAMPLE(vec2( 1, -1), weights9[2]);
	// middle row
	SAMPLE(vec2(-1,  0), weights9[1]);
	SAMPLE(vec2( 0,  0), weights9[0]);
	SAMPLE(vec2( 1,  0), weights9[1]);
	// bottom row
	SAMPLE(vec2(-1,  1), weights9[2]);
	SAMPLE(vec2( 0,  1), weights9[1]);
	SAMPLE(vec2( 1,  1), weights9[2]);

	return shadow;
}

float shadow_low_sampling_distance  = u_shadow_max_distance / 3;
float shadow_mid_sampling_distance  = u_shadow_max_distance / 8; // closer -> high sampling (3x3)

float sampleShadow(float camera_distance, float frag_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	// TODO: use PCSS for the closest range?
	//        or a poisson disc of samples?

	// select samplinmg algorithm basec on distance to camera
	if(camera_distance > shadow_low_sampling_distance)
		return sampleShadow1(frag_depth, atlas_uv, uv_min, uv_max);
	else if(camera_distance > shadow_mid_sampling_distance)
		return sampleShadow5(frag_depth, atlas_uv, uv_min, uv_max);
	return sampleShadow9(frag_depth, atlas_uv, uv_min, uv_max);
}
