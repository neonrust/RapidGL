#version 460 core

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "shadows.glh"
#include "volumetrics.glh"

layout(local_size_x = FROXEL_THREADS_X, local_size_y = FROXEL_THREADS_Y, local_size_z = FROXEL_THREADS_Z) in;

layout(binding = 3)          uniform           sampler2D u_blue_noise;
layout(rgba32f, binding = 5) uniform writeonly image3D   u_out_scatter;
layout(binding = 6)          uniform           sampler3D u_prev_scatter;

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_SHADOW_SLOTS_INFO) readonly buffer ShadowSlotInfoSSBO
{
	ShadowSlotInfo ssbo_shadow_slots[];
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_ALL_TILE_LIGHTS_INDEX)
readonly buffer VolAllTileLightsIndexSSBO
{
	uint ssbo_all_tile_start_index;
	uint ssbo_all_tile_lights[]; // size = avg_lights_per_tile * num_tiles
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_TILE_LIGHTS_INDEX)
readonly buffer VolTileLightsIndexSSBO
{
	IndexRange ssbo_tile_lights[];  // size = num_tiles
};


uniform float u_froxel_zexp;
uniform float u_fog_density; // TODO: noise texture?
uniform float u_fog_anisotropy;
uniform float u_light_max_distance;
uniform float u_volumetric_max_distance;
uniform bool  u_froxel_blend_previous;
uniform float u_froxel_blend_weight; // e.g. 0.2
// uniform float u_falloff_mix;

uniform vec3  u_cam_pos;
uniform float u_near_z;
uniform float u_far_z;
uniform mat4  u_projection;
uniform mat4  u_inv_view_projection;
uniform mat4  u_prev_view;

vec3 pointLightVisibility(GPULight light, vec3 world_pos);
vec3 spotLightVisibility(GPULight light, vec3 world_pos);

float getSquareFalloffAttenuation(float distance_sq, float light_radius_sq);
float getSpotSquareFalloffAttenuation(float distance_sq, float light_radius_sq);
float getSpotAngleAttenuation(vec3 to_light, vec3 spot_axis, float outer_angle, float inner_angle);

float fadeByDistance(float distance, float hard_limit);

float froxelThickness(int z);
float linear_01_to_exp_01_depth(float z);
//vec3 uvToNDC(vec3 uv, float depth_exp);
vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp);
vec3 froxelUV(ivec3 froxel, float noise);
vec3 froxelUV(ivec3 froxel);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, float noise);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj);
float sampleBlueNoise(ivec3 coord);
float phaseFunction(vec3 Wo, vec3 Wi, float g);
vec3 worldToUV(vec3 world_pos, mat4 view_proj);
vec3 worldToFroxelUV(vec3 world_pos, mat4 view);


const float s_min_visibility = 1e-3;
const float s_min_contribution = 1e-5;

void main()
{
	ivec3 froxel = ivec3(gl_GlobalInvocationID.xyz);
	if(froxel.x >= FROXEL_GRID_W ||froxel.y >= FROXEL_GRID_H || froxel.z >= FROXEL_GRID_D)
		return;

	shadow_atlas_texel_size = 1.0 / vec2(textureSize(u_shadow_atlas_single, 0));

	float noise = sampleBlueNoise(froxel) - 0.5f; // * 0.999f

	vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection, noise);
	float thickness  = froxelThickness(froxel.z);

	vec3 total_scattered = vec3(0);

	uvec2 tile = uvec2(froxel.x / FROXELS_PER_TILE, froxel.y / FROXELS_PER_TILE);
	uint tile_index = tile.y*tile_grid.x + tile.x;

	IndexRange lights_range = ssbo_tile_lights[tile_index];

	for(uint index = 0; index < lights_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[lights_range.start_index + index];
		GPULight light = ssbo_lights[light_index];

		vec3 light_to_froxel;
		float distance_sq;
		bool affecting_froxel = true;
		float distance_fade = 1;
		if(! IS_DIR_LIGHT(light))
		{
			light_to_froxel = world_pos - light.position;
			distance_sq = dot(light_to_froxel, light_to_froxel);
			if(distance_sq > light.affect_radius*light.affect_radius)
				affecting_froxel = false; // still need to mix with value from previous frame
			else
			{
				float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
				// fade the volumetrics by distance
				distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));
				// if(distance_fade < s_min_contribution)
				// 	continue;
			}
		}

		vec3 scatter_contrib = vec3(0);

		if(affecting_froxel && distance_fade >= s_min_contribution)
		{
			vec3 visibility = vec3(0);

			if(IS_POINT_LIGHT(light))
				visibility = pointLightVisibility(light, world_pos);
			else if(IS_SPOT_LIGHT(light))
				visibility = spotLightVisibility(light, world_pos);

			if(visibility.x + visibility.y + visibility.z > s_min_visibility)
			{
				vec3 light_direction;
				if(IS_DIR_LIGHT(light))
					light_direction = light.direction;
				else
					light_direction = normalize(light.position - world_pos);

				vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
				float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

				// positional lights are affected by their... uhm, position
				if(IS_POINT_LIGHT(light))
				{
					float falloff_sq = getSquareFalloffAttenuation(distance_sq, light.affect_radius*light.affect_radius);
					// float falloff_lin = 1 - sqrt(distance_sq) / light.affect_radius;
					contribution *= falloff_sq;//mix(falloff_sq, falloff_lin, falloff_lin * u_falloff_mix);
				}
				if(IS_SPOT_LIGHT(light))
				{
					contribution *= getSpotSquareFalloffAttenuation(distance_sq, light.affect_radius*light.affect_radius);
					contribution *= getSpotAngleAttenuation(normalize(light_to_froxel), light.direction, light.outer_angle, light.inner_angle);
				}
				else
					;// TODO: area, tube, sphere & disc

				if(contribution > s_min_contribution)
				{
		        	scatter_contrib = contribution
											* light.color
											* light.intensity
											* light.fog_intensity;
				}
			}
		}

        if(u_froxel_blend_previous)
        {
        	// same as above, but without noise
	        vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection);

	        // find the corresponding UV in the previous froxel grid
	        vec3 prev_uv = worldToUV(world_pos, u_prev_view);
			// vec3 prev_uv = worldToFroxelUV(world_pos, u_prev_view);

	        // only mix with UVs that coincide with the current froxel grid
	        if(all(greaterThanEqual(prev_uv, vec3(0))) && all(lessThanEqual(prev_uv, vec3(1))))
	        {
	            // blend with previous froxel sample
	            vec3 prev_scatter = textureLod(u_prev_scatter, prev_uv, 0).rgb;
            	scatter_contrib = mix(scatter_contrib, prev_scatter, u_froxel_blend_weight);
	        }
			// else
			// 	scatter_contrib = vec3(1, 0, 1);
        }

        total_scattered += scatter_contrib;
	}

	float density = u_fog_density; // TODO: noise texture?
	imageStore(u_out_scatter, froxel, vec4(total_scattered * density, density));
}

float froxelThickness(int z)
{
    return exp(-float(FROXEL_GRID_D - z - 1) / float(FROXEL_GRID_D));
}

float linear_01_to_exp_01_depth(float z)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1 - z_buffer_params_y;

    return (1 / z - z_buffer_params_y) / z_buffer_params_x;
}

vec3 uvToNDC(vec3 uv, float depth_exp)
{
    vec3 ndc;

    ndc.x = 2 * uv.x - 1;
    ndc.y = 2 * uv.y - 1;
    ndc.z = 2 * linear_01_to_exp_01_depth(uv.z) - 1;

    return ndc;
}

vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp)
{
    vec4 p = inv_vp * vec4(ndc, 1);

    p.x /= p.w;
    p.y /= p.w;
    p.z /= p.w;

    return p.xyz;
}

vec3 froxelUV(ivec3 froxel, float noise)
{
    // Exponential View-Z
    float view_z = u_near_z * pow(u_far_z / u_near_z, (float(froxel.z) + 0.5 + noise) / float(FROXEL_GRID_D));

    // float z_norm = log(view_z / u_near_z) /
    //                log(u_far_z / u_near_z);

    return vec3((float(froxel.x) + 0.5) / float(FROXEL_GRID_W),
                (float(froxel.y) + 0.5) / float(FROXEL_GRID_H),
                view_z / u_far_z);
}

vec3 froxelUV(ivec3 froxel)
{
	return froxelUV(froxel, 0);
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, float noise)
{
    vec3 uv = froxelUV(froxel, noise);
    vec3 ndc = uvToNDC(uv, depth_exp);
    return ndcToWorldPos(ndc, inv_view_proj);
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj)
{
	return froxelWorldPos(froxel, depth_exp, inv_view_proj, 0);
}
float sampleBlueNoise(ivec3 coord)
{
	int noiseSize = textureSize(u_blue_noise, 0).x;
    ivec2 noise_coord = (coord.xy + ivec2(0, 1) * coord.z * noiseSize) % noiseSize;
    return texelFetch(u_blue_noise, noise_coord, 0).r;
}

float phaseFunction(vec3 Wo, vec3 Wi, float g)
{
	const float avoid_dbz = 1e-4;
	const float PI = 3.14159265359;

    float cos_theta = dot(Wo, Wi);
    float denom     = 1 + g * g + 2 * g * cos_theta;
    return (1 / (4 * PI)) * (1 - g * g) / max(pow(denom, 1.5f), avoid_dbz);
}

float exp_to_linear_depth(float z, float n, float f)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1.0f - z_buffer_params_y;

    return 1 / (z_buffer_params_x * z + z_buffer_params_y);
}

vec3 ndcToUV(vec3 ndc, float depth_power)
{
    vec3 uv;

    uv.x = ndc.x * 0.5f + 0.5f;
    uv.y = ndc.y * 0.5f + 0.5f;
    uv.z = exp_to_linear_depth(ndc.z * 0.5f + 0.5f, u_near_z, u_far_z);

    // Exponential View-Z
    vec2 params = vec2(float(FROXEL_GRID_D) / log2(u_far_z / u_near_z), -(float(FROXEL_GRID_D) * log2(u_near_z) / log2(u_far_z / u_near_z)));

    float view_z = uv.z * u_far_z;
    uv.z = (max(log2(view_z) * params.x + params.y, 0)) / FROXEL_GRID_D;

    return uv;
}

vec3 worldToNDC(vec3 world_pos, mat4 view_proj)
{
    vec4 p = view_proj * vec4(world_pos, 1);

    if (p.w > 0)
    {
        p.x /= p.w;
        p.y /= p.w;
        p.z /= p.w;
    }

    return p.xyz;
}

vec3 worldToUV(vec3 world_pos, mat4 view)
{
    vec3 ndc = worldToNDC(world_pos, u_projection * view);
    return ndcToUV(ndc, u_froxel_zexp);
}

vec3 worldToFroxelUV(vec3 world_pos, mat4 view)
{
    // Transform into *view space*
    vec4 view_pos = view * vec4(world_pos, 1);

    // Perspective divide not needed (we’re in view space now)
    // viewPos.z is negative in standard right-handed OpenGL camera space.
    float view_z = -view_pos.z;

    // --- X/Y mapping ---
    // Project to NDC
    vec4 clip_pos = u_projection * view_pos;
    vec3 ndc = clip_pos.xyz / clip_pos.w;   // [ -1, 1 ]

    // Map to [0,1]
    // float u = ndc.x * 0.5 + 0.5;
    // float v = ndc.y * 0.5 + 0.5;
    vec2 uv = (ndc * 0.5 + 0.5).xy;

    // --- Z mapping ---
    // Match your exponential partitioning
    // normalize viewZ against far
    float w = log(view_z / u_near_z) / log(u_far_z / u_near_z);

    return vec3(uv, clamp(w, 0, 1));
}

// from pbr_scatter_contrib.glh (slightly modified)
float getSquareFalloffAttenuation(float distance_sq, float light_radius_squared)
{
    // float distance_square = dot(pos_to_light, pos_to_light);
    float factor          = distance_sq / light_radius_squared;
    float smooth_factor   = max(1.0 - factor * factor, 0.0);

    return (smooth_factor * smooth_factor) / max(distance_sq, 1e-5);
}

// TODO: combine these two functions?
float getSpotSquareFalloffAttenuation(float distance_sq, float light_radius_sq)
{
    // float distance_square = dot(pos_to_light, pos_to_light);
    float factor          = distance_sq / light_radius_sq;
    float smooth_factor   = max(1.0 - factor * factor, 0.0);

    // minimize the "warbling wasp stinger" by fading out near the apex
    float dist_fraction = distance_sq / light_radius_sq;
   	smooth_factor *= smoothstep(0.f, 0.01f, dist_fraction);

    return (smooth_factor * smooth_factor) / max(distance_sq, 1e-5);
}

float getSpotAngleAttenuation(vec3 to_light, vec3 spot_dir, float outer_angle, float inner_angle)
{
    // the scale and offset computations can be done CPU-side
    float cos_outer   = cos(outer_angle);

    float spot_scale  = 1.0 / max(cos(inner_angle) - cos_outer, 1e-5);
    float spot_offset = -cos_outer * spot_scale;

    float cd          = dot(spot_dir, to_light);
    float attenuation = clamp(cd * spot_scale + spot_offset, 0.0, 1.0);

    return attenuation * attenuation;
}

float sampleShadow(float current_depth, vec2 atlas_uv)
{
	float sample_depth = textureLod(u_shadow_atlas_single, atlas_uv, 0).r;
 	return current_depth > sample_depth ? 0 : 1;
}

float fadeLightByDistance(GPULight light)
{
	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	// fade the whole light by distance
	return fadeByDistance(light_edge_distance, u_light_max_distance);
}

vec2 calculateShadowUV(vec3 world_pos, mat4 view_proj, vec4 rect, out vec4 rect_uv);
float shadowVisibility(vec3 light_to_frag, vec3 world_pos, GPULight light, mat4 view_proj, vec4 rect);
float sampleShadow(float distance, float normalized_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max);

vec3 pointLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	vec3 light_to_frag = world_pos - light.position;

	mat4 view_proj;
	vec4 rect; // shadow slot rectangle in atlas, in absolute pixels
	detectCubeFaceSlot(light_to_frag, slot_info, view_proj, rect);

	float shadow_visibility = shadowVisibility(light_to_frag, world_pos, light, view_proj, rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

vec3 spotLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	mat4 view_proj = slot_info.view_proj[0];
	vec4 rect = slot_info.atlas_rect[0];

	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(world_pos, view_proj, rect, rect_uv);

	vec3 light_to_frag = world_pos - light.position;
	float shadow_visibility = shadowVisibility(light_to_frag, world_pos, light, view_proj, rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

float sampleShadow(float current_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	return texture(u_shadow_atlas_single, atlas_uv).r > current_depth? 1: 0;
}

float shadowVisibility(vec3 light_to_frag, vec3 world_pos, GPULight light, mat4 view_proj, vec4 rect)
{
	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(world_pos, view_proj, rect, rect_uv);

	float light_distance = length(light_to_frag);
	float normalized_depth = light_distance / light.affect_radius;

	vec2 uv_min = rect_uv.xy;
	vec2 uv_max = rect_uv.xy + rect_uv.zw - shadow_atlas_texel_size;
	return sampleShadow(normalized_depth, atlas_uv, uv_min, uv_max);
}

const float SOFT_DISTANCE_LIMIT = 0.8; // fraction of hard limit

float fadeByDistance(float distance, float hard_limit)
{
	return 1 - smoothstep(hard_limit*SOFT_DISTANCE_LIMIT, hard_limit, distance);
}
