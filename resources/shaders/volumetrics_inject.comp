#version 460 core

const float PI = 3.14159265359;
const uint MAX_CASCADES = 4; // TODO: should be set from ShadowAtlas::MAX_CASCADES

#include "shared-structs.glh"
#include "shadows.glh"
#include "volumetrics.glh"
#include "light.glh"
#include "noise.glh"


layout(local_size_x = FROXEL_THREADS_X, local_size_y = FROXEL_THREADS_Y, local_size_z = FROXEL_THREADS_Z) in;

layout(binding = 3)          uniform           sampler2D u_blue_noise;
layout(binding = 5, rgba16f) uniform writeonly image3D   u_out_scatter;
layout(binding = 6)          uniform           sampler3D u_prev_scatter;

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_SHADOW_SLOTS_INFO) readonly buffer ShadowSlotInfoSSBO
{
	ShadowSlotInfo ssbo_shadow_slots[];
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_ALL_TILE_LIGHTS_INDEX)
readonly buffer VolAllTileLightsIndexSSBO
{
	uint ssbo_all_tile_start_index;
	uint ssbo_all_tile_lights[]; // size = avg_lights_per_tile * num_tiles
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_TILE_LIGHTS_INDEX)
readonly buffer VolTileLightsIndexSSBO
{
	IndexRange ssbo_tile_lights[];  // size = LIGHT_TYPE__COUNT * num_tiles
};

//uniform uint u_frame_index;
uniform float u_froxel_zexp;
uniform float u_fog_density; // TODO: noise texture?
uniform float u_fog_anisotropy;
uniform bool  u_fog_noise;
uniform vec3 u_fog_noise_offset;
uniform vec3 u_fog_noise_frequency;
uniform float u_light_max_distance;
uniform float u_volumetric_max_distance;
uniform bool  u_froxel_z_noise;
uniform bool  u_froxel_blend_previous;
uniform float u_froxel_blend_weight; // e.g. 0.2

uniform vec3  u_cam_pos;
uniform float u_near_z;
uniform float u_far_z;
uniform mat4  u_view;
uniform mat4  u_projection;
uniform mat4  u_inv_view_projection;
uniform mat4  u_prev_view;
uniform mat4  u_csm_light_view_space[MAX_CASCADES];


const float DIR_LIGHT_SCALE = 0.3;

vec3 pointLightVisibility(GPULight light, vec3 world_pos);
vec3 spotLightVisibility(GPULight light, vec3 world_pos);
vec3 dirLightVisibility(GPULight light, vec3 world_pos);

float getSpotAngleAttenuation(vec3 to_light, vec3 spot_axis, float outer_angle, float inner_angle);

float fadeByDistance(float distance, float hard_limit);

float froxelThickness(int z);
float linear_01_to_exp_01_depth(float z);
vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp);
vec3 froxelUV(ivec3 froxel, float noise);
vec3 froxelUV(ivec3 froxel);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, vec3 noise);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj);
float sampleBlueNoise(ivec3 coord);
float phaseFunction(vec3 Wo, vec3 Wi, float g);
vec3 worldToUV(vec3 world_pos, mat4 view_proj);

uint computeSpotNumSamples(vec3 world_pos, GPULight spot, float maxWidth, uint  maxSamples);

vec3 scatterPointLight(GPULight light, vec3 world_pos);
vec3 scatterDirLight(GPULight light, vec3 world_pos);
vec3 scatterSpotLight(GPULight light, vec3 world_pos);
vec3 scatterRectLight(GPULight light, vec3 world_pos);
vec3 scatterTubeLight(GPULight light, vec3 world_pos);
vec3 scatterSphereLight(GPULight light, vec3 world_pos);
vec3 scatterDiscLight(GPULight light, vec3 world_pos);

float halton(float index, uint base);

void main()
{
	uint num_tiles = tile_grid.x * tile_grid.y;

	ivec3 froxel = ivec3(gl_GlobalInvocationID.xyz);
	if(froxel.x >= FROXEL_GRID_W ||froxel.y >= FROXEL_GRID_H || froxel.z >= FROXEL_GRID_D)
		return;

	shadow_atlas_texel_size = 1.0 / vec2(textureSize(u_shadow_atlas_single, 0));

	float n = u_froxel_z_noise? sampleBlueNoise(froxel) - 0.5f : 0; // * 0.999f
	vec3 noise = vec3(n);
	// spatial noise
	// vec3 noise;
	// noise.x = halton(u_frame_index, 2);
	// noise.y = halton(u_frame_index, 3);
	// noise.z = noise.y;
	// noise = noise * 2.0 - 1.0;  // [ -1, 1 ]

	vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection, noise);
	float thickness  = froxelThickness(froxel.z);

	uvec2 tile = uvec2(froxel.x / FROXELS_PER_TILE, froxel.y / FROXELS_PER_TILE);
	uint tile_index = tile.y*tile_grid.x + tile.x;

	vec3 total_scattered = vec3(0);
	float density = u_fog_density;  // TODO: 3D texture / noise?

	IndexRange lights_range = ssbo_tile_lights[LIGHT_TYPE_POINT * num_tiles + tile_index];
	for(uint index = 0; index < lights_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[lights_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterPointLight(light, world_pos);
	}

	IndexRange dir_range = ssbo_tile_lights[LIGHT_TYPE_DIRECTIONAL * num_tiles + tile_index];
	for(uint index = 0; index < dir_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[dir_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterDirLight(light, world_pos);
	}

	IndexRange spot_range = ssbo_tile_lights[LIGHT_TYPE_SPOT * num_tiles + tile_index];
	for(uint index = 0; index < spot_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[spot_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterSpotLight(light, world_pos);
	}

	IndexRange rect_range = ssbo_tile_lights[LIGHT_TYPE_RECT * num_tiles + tile_index];
	for(uint index = 0; index < rect_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[rect_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterRectLight(light, world_pos);
	}

	IndexRange tube_range = ssbo_tile_lights[LIGHT_TYPE_TUBE * num_tiles + tile_index];
	for(uint index = 0; index < tube_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[tube_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterTubeLight(light, world_pos);
	}

	IndexRange sphere_range = ssbo_tile_lights[LIGHT_TYPE_SPHERE * num_tiles + tile_index];
	for(uint index = 0; index < sphere_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[sphere_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterSphereLight(light, world_pos);
	}

	IndexRange disc_range = ssbo_tile_lights[LIGHT_TYPE_DISC * num_tiles + tile_index];
	for(uint index = 0; index < disc_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[disc_range.start_index + index];
		GPULight light = ssbo_lights[light_index];
		total_scattered += scatterDiscLight(light, world_pos);
	}

	total_scattered *= u_fog_density;

	if(u_fog_noise)
	{
		float noise_density = perlinNoise((world_pos + u_fog_noise_offset) * u_fog_noise_frequency);
		noise_density = noise_density * 0.5 + 0.5;  // -> [ 0, 1 ]
		total_scattered *= noise_density;
		// absorption *= density;
	}

	if(u_froxel_blend_previous)
	{
		// same as above, but without noise
		vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection);

		// find the corresponding UV in the previous froxel grid
		vec3 prev_uv = worldToUV(world_pos, u_prev_view);
		// reject UV outside the froxel grid (looks better with temporal blending)
		if(all(greaterThanEqual(prev_uv, vec3(0))) && all(lessThanEqual(prev_uv, vec3(1))))
		{
			// sample previous froxel
			vec3 prev_scattered = textureLod(u_prev_scatter, prev_uv, 0).rgb;
			total_scattered = mix(total_scattered, prev_scattered, u_froxel_blend_weight);
		}
	}

	imageStore(u_out_scatter, froxel, vec4(total_scattered, density));
}

float samplePointLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleSpotLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleRectLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleTubeLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleSphereLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleDiscLight(GPULight light, vec3 world_pos, float distance_sq);

vec3 scatterPointLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	if(distance_fade >= 0)
	{
		vec3 visibility = pointLightVisibility(light, world_pos);

		if(visibility.x + visibility.y + visibility.z > 0)
		{
			vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
			vec3 light_direction = normalize(light.position - world_pos);
			float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);
			contribution *= samplePointLight(light, world_pos, distance_sq);

			// contribution = min(contribution, light.intensity * 5e-3);
        	return contribution
         			* light.color
					* light.intensity
					* light.fog_intensity;
		}
	}

    return vec3(0);
}

vec3 scatterDirLight(GPULight light, vec3 world_pos)
{
	vec3 visibility = dirLightVisibility(light, world_pos);
    return visibility * light.color * light.intensity * light.fog_intensity * DIR_LIGHT_SCALE;
}

vec3 scatterSpotLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	if(distance_fade >= 0)
	{
		vec3 visibility = spotLightVisibility(light, world_pos);

		if(visibility.x + visibility.y + visibility.z > 0)
		{
			vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
			vec3 light_direction = normalize(light.position - world_pos);
			float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);
			contribution *= sampleSpotLight(light, world_pos, distance_sq);

			// contribution = min(contribution, light.intensity * 5e-3);
	      	return contribution
					* light.color
					* light.intensity
					* light.fog_intensity;
		}
	}

	return vec3(0);
}

vec3 scatterRectLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	vec3 scatter_contrib = vec3(0);

	if(distance_fade >= 0)
	{
		vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
		vec3 light_direction = normalize(light.position - world_pos);
		float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

		contribution *= sampleRectLight(light, world_pos, distance_sq);
		light.intensity = pow(light.intensity, RECT_INTENSITY_POWER);

		// contribution = min(contribution, light.intensity * 5e-3);
       	return contribution
				* light.color
				* light.intensity
				* light.fog_intensity;
	}

   return vec3(0);
}

vec3 scatterTubeLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	if(distance_fade >= 0)
	{
		vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
		vec3 light_direction = normalize(light.position - world_pos);
		float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

		contribution *= sampleTubeLight(light, world_pos, distance_sq);

		// contribution = min(contribution, light.intensity * 5e-3);
       	return contribution
				* light.color
				* light.intensity
				* light.fog_intensity;
	}

	return vec3(0);
}

vec3 scatterSphereLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	if(distance_fade >= 0)
	{
		vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
		vec3 light_direction = normalize(light.position - world_pos);
		float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

		contribution *= sampleSphereLight(light, world_pos, distance_sq);

		// contribution = min(contribution, light.intensity * 5e-3);
    	return contribution
				* light.color
				* light.intensity
				* light.fog_intensity;
	}

   return vec3(0);
}

vec3 scatterDiscLight(GPULight light, vec3 world_pos)
{
	vec3 light_to_froxel = world_pos - light.position;
	float distance_sq = dot(light_to_froxel, light_to_froxel);
	if(distance_sq > light.affect_radius*light.affect_radius)
		return vec3(0);

	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	float distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));

	if(distance_fade >= 0)
	{
		vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
		vec3 light_direction = normalize(light.position - world_pos);
		float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

		contribution *= sampleDiscLight(light, world_pos, distance_sq);
		light.intensity = pow(light.intensity, RECT_INTENSITY_POWER);

		// contribution = min(contribution, light.intensity * 5e-3);
       	return contribution
				* light.color
				* light.intensity
				* light.fog_intensity;
	}

   return vec3(0);
}


float fogLightFalloff(float distance_sq, float light_radius_sq)
{
	// separate function, if maybe some special falloff is needed,
	//   otherwise, the regular lightFalloff() could be used directly
	return lightFalloff(distance_sq, light_radius_sq);
}

float samplePointLight(GPULight light, vec3 world_pos, float distance_sq)
{
	return fogLightFalloff(distance_sq, light.affect_radius*light.affect_radius);
}

float coneDistanceWithDiameter(GPULight spot, float diameter);
vec3 closest_point(vec3 test_point, vec3 line1, vec3 line2);

float sampleSpotLight(GPULight light, vec3 world_pos, float distance_sq)
{
	float radius_sq = light.affect_radius*light.affect_radius;

	float energy = fogLightFalloff(distance_sq, radius_sq);

	vec3 light_to_froxel = world_pos - light.position;
	energy *= spotRadialFalloff(normalize(light_to_froxel), -light.direction, light.outer_angle, light.inner_angle);
	energy *= pow(sin(light.outer_angle), 2); // or something like it

	// cut off apex where narrower than a specific cone diameter
 	float dist_fraction = distance_sq / radius_sq;
	float cutoff_point = coneDistanceWithDiameter(light, 0.5);
	cutoff_point *= cutoff_point;
	cutoff_point /= radius_sq;
   	energy *= smoothstep(0.f, cutoff_point, dist_fraction);

	return energy;
}

float sampleRectLight(GPULight light, vec3 sample_pos, float distance_sq)
{
	// TODO: degenerate into point light at large distance

	vec4 points[4];
    points[0] = vec4(light.position + light.shape_data[0].xyz, 1);
    points[2] = vec4(light.position + light.shape_data[1].xyz, 1); // hmm point order?
    points[1] = vec4(light.position + light.shape_data[2].xyz, 1);
    points[3] = vec4(light.position + light.shape_data[3].xyz, 1);

	vec3 shape_cross = cross(points[1].xyz - points[0].xyz,
	                         points[0].xyz - points[3].xyz);
	vec3 normal = normalize(shape_cross);

	// compute closest point on rectangle to sample_pos
	vec3 corner0 = points[0].xyz;
	vec3 edgeU = points[1].xyz - corner0;
	vec3 edgeV = points[3].xyz - corner0;
	vec3 center = corner0 + 0.5 * (edgeU + edgeV);
	float halfU = length(edgeU) * 0.5;
	float halfV = length(edgeV) * 0.5;
	vec3 dirU = (halfU > 1e-6) ? normalize(edgeU) : vec3(1,0,0);
	vec3 dirV = (halfV > 1e-6) ? normalize(edgeV) : vec3(0,1,0);

	vec3 local = sample_pos - center;
	float u = dot(local, dirU);
	float v = dot(local, dirV);
	float cu = clamp(u, -halfU, halfU);
	float cv = clamp(v, -halfV, halfV);
	vec3 closest = center + dirU * cu + dirV * cv;

	float dist_sq_closest = dot(sample_pos - closest, sample_pos - closest);

	vec3 to_sample = sample_pos - light.position;
	float dist = sqrt(distance_sq);
	vec3 dir = to_sample / max(dist, 1e-6);

	// rough estimate of projected solid angle;
	// average distance from sample to four corners
	float avg_d = 0;
	for(int i = 0; i < 4; ++i)
		avg_d += length(light.shape_data[i].xyz - sample_pos);
	avg_d *= 0.25;

	float radius_sq = light.affect_radius * light.affect_radius;

	float area_scale = radius_sq / (avg_d * avg_d + 1e-6);

	// simple Lambert term to fade off-axis contributions
	float n_dot_l = dot(normal, dir);

	if(IS_DOUBLE_SIDED(light))
	{
		n_dot_l = abs(n_dot_l);
		area_scale *= 0.5;
	}
	n_dot_l = max(n_dot_l, 0);

	float falloff = fogLightFalloff(dist_sq_closest, radius_sq);
	      falloff *= 1/dist_sq_closest; // allso apply square falloff, to mimic-ish LTC fall off

	return n_dot_l * falloff;// * area_scale / 100;
}

float sampleTubeLight(GPULight light, vec3 world_pos, float distance_sq)
{
	// TODO: degenerate into point light at large distance

	// get brightness from closest point

	vec3 point_a = light.position + light.shape_data[0].xyz;
	vec3 point_b = light.position + light.shape_data[1].xyz;
	float thickness = light.shape_data[2].x * 0.5;

	vec3 closest = closest_point(world_pos, point_a, point_b);
	float distance = distance(world_pos, closest) - thickness;
	// scale radius down slightly
	float radius_sq = pow(light.affect_radius * light.affect_radius, 0.8);
	return fogLightFalloff(distance*distance, radius_sq);
}

float sampleSphereLight(GPULight light, vec3 world_pos, float distance_sq)
{
	// simulate using a point light
	// TODO: degenerate into point light at large distance

	float radius = light.shape_data[0].x;
	light.affect_radius += radius;
	return samplePointLight(light, world_pos, distance_sq);
}

float sampleDiscLight(GPULight light, vec3 world_pos, float distance_sq)
{
	// simulate using a rect light of the same size
	// TODO: degenerate into point light at large distance

	vec3 orthogonal = vec3(0, 1, 0);
	if(orthogonal == light.direction)
		orthogonal = vec3(0, 0, 1);

	vec3 right = cross(light.direction, orthogonal);
	vec3 up    = cross(right, light.direction);

	float radius = light.shape_data[0].x;
	vec3 offset_h = right * radius;
	vec3 offset_v = up    * radius;

	GPULight faux_rect = light;
	faux_rect.type_flags = LIGHT_TYPE_RECT;
	faux_rect.shape_data[0] = vec4(+ offset_h - offset_v, 1);
	faux_rect.shape_data[1] = vec4(- offset_h - offset_v, 1);
	faux_rect.shape_data[2] = vec4(+ offset_h + offset_v, 1);
	faux_rect.shape_data[3] = vec4(- offset_h + offset_v, 1);

	return sampleRectLight(faux_rect, world_pos, distance_sq);
}

vec3 closest_point(vec3 test_point, vec3 line1, vec3 line2)
{
	vec3 ba = test_point - line1;
	vec3 bc = line2 - line1;
	float d = dot(ba, bc);
	float len = length(bc);
	float param = 0;
	if (len != 0)
		param = clamp(d / (len * len), 0, 1);
	return line1 + bc * param;
}

float halton(float index, uint base)
{
	float r = 0.0f;
	float f = 1.0f;

	while (index > 0.0f)
	{
		f /= base;
		r += f * mod(index, float(base));
		index = floor(index / float(base));
	}
	return r;
}

float froxelThickness(int z)
{
    return exp(-float(FROXEL_GRID_D - z - 1) / float(FROXEL_GRID_D));
}

float linear_01_to_exp_01_depth(float z)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1 - z_buffer_params_y;

    return (1 / z - z_buffer_params_y) / z_buffer_params_x;
}

vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp)
{
    vec4 p = inv_vp * vec4(ndc, 1);

    p.x /= p.w;
    p.y /= p.w;
    p.z /= p.w;

    return p.xyz;
}

vec3 froxelUV(ivec3 froxel, float noise)
{
    // Exponential View-Z
    float view_z = u_near_z * pow(u_far_z / u_near_z, (float(froxel.z) + 0.5 + noise) / float(FROXEL_GRID_D));

    return vec3((float(froxel.x) + 0.5) / float(FROXEL_GRID_W),
                (float(froxel.y) + 0.5) / float(FROXEL_GRID_H),
                view_z / u_far_z);
}

vec3 froxelUV(ivec3 froxel)
{
	return froxelUV(froxel, 0);
}

vec3 uvToNDC(vec3 uv, float depth_exp)
{
    vec3 ndc;

    ndc.x = 2 * uv.x - 1;
    ndc.y = 2 * uv.y - 1;
    ndc.z = 2 * linear_01_to_exp_01_depth(uv.z) - 1;

    return ndc;
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, vec3 noise)
{
    vec3 uv = froxelUV(froxel, noise.z);
    vec3 ndc = uvToNDC(uv, depth_exp);
    return ndcToWorldPos(ndc, inv_view_proj) + vec3(noise.xy/vec2(tile_grid)/4, 0);
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj)
{
	return froxelWorldPos(froxel, depth_exp, inv_view_proj, vec3(0));
}

float sampleBlueNoise(ivec3 coord)
{
	int noiseSize = textureSize(u_blue_noise, 0).x;
    ivec2 noise_coord = (coord.xy + ivec2(0, 1) * coord.z * noiseSize) % noiseSize;
    return texelFetch(u_blue_noise, noise_coord, 0).r;
}

float phaseFunction(vec3 Wo, vec3 Wi, float g)
{
	float cos_theta = dot(Wo, Wi);
    float denom     = 1 + g * g + 2 * g * cos_theta;
    return (1 / (4 * PI)) * (1 - g * g) / max(pow(denom, 1.5f), 1e-4);
}

float exp_to_linear_depth(float z, float n, float f)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1.0f - z_buffer_params_y;

    return 1 / (z_buffer_params_x * z + z_buffer_params_y);
}

vec3 ndcToUV(vec3 ndc, float depth_power)
{
    vec3 uv;

    uv.x = ndc.x * 0.5f + 0.5f;
    uv.y = ndc.y * 0.5f + 0.5f;
    uv.z = exp_to_linear_depth(ndc.z * 0.5f + 0.5f, u_near_z, u_far_z);

    // Exponential View-Z
    vec2 params = vec2(float(FROXEL_GRID_D) / log2(u_far_z / u_near_z), -(float(FROXEL_GRID_D) * log2(u_near_z) / log2(u_far_z / u_near_z)));

    float view_z = uv.z * u_far_z;
    uv.z = (max(log2(view_z) * params.x + params.y, 0)) / FROXEL_GRID_D;

    return uv;
}

vec3 worldToNDC(vec3 world_pos, mat4 view_proj)
{
    vec4 p = view_proj * vec4(world_pos, 1);

    if (p.w > 0)
    {
        p.x /= p.w;
        p.y /= p.w;
        p.z /= p.w;
    }

    return p.xyz;
}

vec3 worldToUV(vec3 world_pos, mat4 view)
{
    vec3 ndc = worldToNDC(world_pos, u_projection * view);
    return ndcToUV(ndc, u_froxel_zexp);
}

float getSpotAngleAttenuation(vec3 to_light, vec3 spot_dir, float outer_angle, float inner_angle)
{
    // the scale and offset computations can be done CPU-side
    float cos_outer   = cos(outer_angle);

    float spot_scale  = 1.0 / max(cos(inner_angle) - cos_outer, 1e-5);
    float spot_offset = -cos_outer * spot_scale;

    float cd          = dot(spot_dir, to_light);
    float attenuation = clamp(cd * spot_scale + spot_offset, 0.0, 1.0);

    return attenuation * attenuation;
}

float sampleShadow(float current_depth, vec2 atlas_uv)
{
	return texture(u_shadow_atlas_single, atlas_uv).r > current_depth? 1: 0;
}

float fadeLightByDistance(GPULight light)
{
	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	// fade the whole light by distance
	return fadeByDistance(light_edge_distance, u_light_max_distance);
}

//vec2 calculateShadowUV(vec3 world_pos, mat4 view_proj, vec4 rect, out vec4 rect_uv);
float shadowVisibility(vec3 clip_pos, GPULight light, vec4 rect);

vec3 pointLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	vec3 light_to_frag = world_pos - light.position;

	mat4 view_proj;
	vec4 slot_rect;
	float texel_size_unused;
	detectCubeFaceSlot(light_to_frag, slot_info, view_proj, slot_rect, texel_size_unused);

	vec4 clip_pos = view_proj * vec4(world_pos, 1);
	vec3 ndc_pos = clip_pos.xyz / clip_pos.w; // [-1, 1]
	vec3 uv_pos = ndc_pos * 0.5 + 0.5; // [0, 1]

	float shadow_visibility = shadowVisibility(uv_pos, light, slot_rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

vec3 dirLightVisibility(GPULight light, vec3 world_pos)
{
	if(! IS_SHADOW_CASTER(light))
		return vec3(1);

	// vec3 cascade_debug_indicator = vec3(0.0, 0.0, 0.0);
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = 1;
	// float shadow_fade = fadeByDistance(camera_distance, u_shadow_dir_max_distance);
	// if(shadow_fade == 0)
	// 	return vec3(0);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(1);  // no shadow map in use

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	// NOTE: this ugliness is a lot faster than doing it minimally, b/c GPU reasons
	mat4 view_proj_0 = slot_info.view_proj[0];
	mat4 view_proj_1 = slot_info.view_proj[1];
	mat4 view_proj_2 = slot_info.view_proj[2];
	mat4 view_proj_3 = slot_info.view_proj[3];

	uvec4 slot_rect_0 = slot_info.atlas_rect[0];
	uvec4 slot_rect_1 = slot_info.atlas_rect[1];
	uvec4 slot_rect_2 = slot_info.atlas_rect[2];
	uvec4 slot_rect_3 = slot_info.atlas_rect[3];

	float texel_size_0 = slot_info.texel_size[0];
	float texel_size_1 = slot_info.texel_size[1];
	float texel_size_2 = slot_info.texel_size[2];
	float texel_size_3 = slot_info.texel_size[3];

	vec4 view_pos = u_view * vec4(world_pos, 1);
	// vec4 view_pos_0 = u_csm_light_view_space[0] * vec4(world_pos, 1);
	// vec4 view_pos_1 = u_csm_light_view_space[1] * vec4(world_pos, 1);
	// vec4 view_pos_2 = u_csm_light_view_space[2] * vec4(world_pos, 1);
	// vec4 view_pos_3 = u_csm_light_view_space[3] * vec4(world_pos, 1);

	// use depth splits to find which cascade contains the fragment,
	//   that then corresponds to which slot to use
	//   note that values are negative; X > Y means X is closer to camera than Y
	uint cascade_index = 3;
 	if(view_pos.z > u_csm_split_depth[0])
  		cascade_index = 0;
   	else if(view_pos.z > u_csm_split_depth[1])
   		cascade_index = 1;
   	else if(view_pos.z > u_csm_split_depth[2])
   		cascade_index = 2;

	mat4 view_proj;
	uvec4 slot_rect;
	// float texel_size_unused;
	if(cascade_index == 0)
	{
		view_proj = view_proj_0;
		slot_rect = slot_rect_0;
		// texel_size_unused = texel_size_0;
	}
	else if(cascade_index == 1)
	{
		view_proj = view_proj_1;
		slot_rect = slot_rect_1;
		// texel_size_unused = texel_size_1;
	}
	else if(cascade_index == 2)
	{
		view_proj = view_proj_2;
		slot_rect = slot_rect_2;
		// texel_size_unused = texel_size_2;
	}
	else if(cascade_index == 3)
	{
		view_proj = view_proj_3;
		slot_rect = slot_rect_3;
		// texel_size_unused = texel_size_3;
	}

	vec4 clip_pos = view_proj * vec4(world_pos, 1);
	vec3 ndc_pos = clip_pos.xyz; // b/c .w = 1
	vec3 uv_pos = ndc_pos * 0.5 + 0.5; // [0, 1]

	float shadow_visibility = shadowVisibility(uv_pos, light, slot_rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	vec3 visible = vec3(shadow_faded);

	return visible;
}

vec3 spotLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	mat4 view_proj = slot_info.view_proj[0];
	vec4 slot_rect = slot_info.atlas_rect[0];
	// float texel_size = slot_info.texel_size[0];

	vec4 clip_pos = view_proj * vec4(world_pos, 1);
	vec3 ndc_pos = clip_pos.xyz / clip_pos.w; // [-1, 1]
	vec3 uv_pos = ndc_pos * 0.5 + 0.5; // [0, 1]
	float shadow_visibility = shadowVisibility(uv_pos, light, slot_rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

float shadowVisibility(vec3 uv_pos, GPULight light, vec4 slot_rect)
{
	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(uv_pos, slot_rect, rect_uv);

	float uv_depth = uv_pos.z;

	return sampleShadow(uv_depth, atlas_uv);
}

const float SOFT_DISTANCE_LIMIT = 0.8; // fraction of hard limit

float fadeByDistance(float distance, float hard_limit)
{
	return 1 - smoothstep(hard_limit*SOFT_DISTANCE_LIMIT, hard_limit, distance);
}

float coneDiameterAtPoint(vec3 world_pos, GPULight spot)
{
    float axialDist = dot(world_pos - spot.position, spot.direction);
    axialDist = max(axialDist, 0.0); // only forward of apex

    float tanHalf = tan(spot.outer_angle);
    return 2 * axialDist * tanHalf;
}

float coneDistanceWithDiameter(GPULight spot, float diameter)
{
	return diameter / (2*tan(spot.outer_angle));
}

uint computeSpotNumSamples(
    vec3 world_pos,    // the candidate sample position (within the froxel)
    GPULight spot,
    float maxWidth,    // width that maps to full up-sampling
    uint  maxSamples   // max sample count (e.g. 4)
)
{
	const float minWidth = 0;    // width threshold where we start to up-sample

	float w = coneDiameterAtPoint(world_pos, spot);
    if(w <= minWidth)
    	return 0;

    // viewFactor: 0 = looking exactly down cone, 1 = side-on
    vec3 viewDir = normalize(u_cam_pos - world_pos);
    float cosView = dot(viewDir, normalize(spot.direction));
    float viewFactor = 1 - abs(cosView);

    // map width to [0..1]
    float t = clamp((w - minWidth) / max(1e-6, maxWidth - minWidth), 0, 1);
    float importance = t * viewFactor; // weighing both width and viewing angle

    float fcount = 1 + importance * float(maxSamples - 1);
    return int(max(1, floor(fcount + 0.5f)));
}
