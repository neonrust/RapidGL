#version 460 core

const float PI = 3.14159265359;

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "shadows.glh"
#include "volumetrics.glh"
#include "noise.glh"

layout(local_size_x = FROXEL_THREADS_X, local_size_y = FROXEL_THREADS_Y, local_size_z = FROXEL_THREADS_Z) in;

layout(binding = 3)          uniform           sampler2D u_blue_noise;
layout(binding = 5, rgba16f) uniform writeonly image3D   u_out_scatter;
layout(binding = 6)          uniform           sampler3D u_prev_scatter;

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_SHADOW_SLOTS_INFO) readonly buffer ShadowSlotInfoSSBO
{
	ShadowSlotInfo ssbo_shadow_slots[];
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_ALL_TILE_LIGHTS_INDEX)
readonly buffer VolAllTileLightsIndexSSBO
{
	uint ssbo_all_tile_start_index;
	uint ssbo_all_tile_lights[]; // size = avg_lights_per_tile * num_tiles
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_TILE_LIGHTS_INDEX)
readonly buffer VolTileLightsIndexSSBO
{
	IndexRange ssbo_tile_lights[];  // size = num_tiles
};


uniform float u_froxel_zexp;
uniform float u_fog_density; // TODO: noise texture?
uniform float u_fog_anisotropy;
uniform bool  u_fog_noise;
uniform vec3 u_fog_noise_offset;
uniform vec3 u_fog_noise_frequency;
uniform float u_light_max_distance;
uniform float u_volumetric_max_distance;
uniform bool  u_froxel_z_noise;
uniform bool  u_froxel_blend_previous;
uniform float u_froxel_blend_weight; // e.g. 0.2

uniform vec3  u_cam_pos;
uniform float u_near_z;
uniform float u_far_z;
uniform mat4  u_projection;
uniform mat4  u_inv_view_projection;
uniform mat4  u_prev_view;
uniform float u_falloff_power;

vec3 pointLightVisibility(GPULight light, vec3 world_pos);
vec3 spotLightVisibility(GPULight light, vec3 world_pos);

float getSquareFalloffAttenuation(float distance_sq, float light_radius_sq);
float getSpotSquareFalloffAttenuation(float distance_sq, float light_radius_sq);
float getSpotAngleAttenuation(vec3 to_light, vec3 spot_axis, float outer_angle, float inner_angle);

float fadeByDistance(float distance, float hard_limit);

float froxelThickness(int z);
float linear_01_to_exp_01_depth(float z);
//vec3 uvToNDC(vec3 uv, float depth_exp);
vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp);
vec3 froxelUV(ivec3 froxel, float noise);
vec3 froxelUV(ivec3 froxel);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, vec3 noise);
vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj);
float sampleBlueNoise(ivec3 coord);
float phaseFunction(vec3 Wo, vec3 Wi, float g);
vec3 worldToUV(vec3 world_pos, mat4 view_proj);
vec3 worldToFroxelUV(vec3 world_pos, mat4 view);

float fogDistanceFalloff(float distance, float light_radius);
uint computeSpotNumSamples(vec3 world_pos, GPULight spot, float maxWidth, uint  maxSamples);

float samplePointLight(GPULight light, vec3 world_pos, float distance_sq);
float sampleSpotLight(GPULight light, vec3 world_pos, float distance_sq, float slice_thickness);
float sampleAreaLight(GPULight light, vec3 world_pos, float distance_sq);


const float s_min_visibility = 1e-3;
const float s_min_contribution = 1e-5;

void main()
{
	ivec3 froxel = ivec3(gl_GlobalInvocationID.xyz);
	if(froxel.x >= FROXEL_GRID_W ||froxel.y >= FROXEL_GRID_H || froxel.z >= FROXEL_GRID_D)
		return;

	shadow_atlas_texel_size = 1.0 / vec2(textureSize(u_shadow_atlas_single, 0));

	float n = u_froxel_z_noise? sampleBlueNoise(froxel) - 0.5f : 0; // * 0.999f
	vec3 noise = vec3(n);

	vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection, noise);
	float thickness  = froxelThickness(froxel.z);

	uvec2 tile = uvec2(froxel.x / FROXELS_PER_TILE, froxel.y / FROXELS_PER_TILE);
	uint tile_index = tile.y*tile_grid.x + tile.x;

	IndexRange lights_range = ssbo_tile_lights[tile_index];


	vec3 total_scattered = vec3(0);

	for(uint index = 0; index < lights_range.count; ++index)
	{
		uint light_index = ssbo_all_tile_lights[lights_range.start_index + index];
		GPULight light = ssbo_lights[light_index];

		vec3 light_to_froxel;
		float distance_sq;
		bool affecting_froxel = true;
		float distance_fade = 1;
		if(! IS_DIR_LIGHT(light))
		{
			light_to_froxel = world_pos - light.position;
			distance_sq = dot(light_to_froxel, light_to_froxel);
			if(distance_sq > light.affect_radius*light.affect_radius)
				affecting_froxel = false; // still need to mix with value from previous frame
			else
			{
				float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
				// fade the volumetrics by distance
				distance_fade = fadeByDistance(light_edge_distance, min(u_light_max_distance, u_volumetric_max_distance));
			}
		}

		vec3 scatter_contrib = vec3(0);

		if(affecting_froxel && distance_fade >= s_min_contribution)
		{
			vec3 visibility = vec3(1);

			if(IS_POINT_LIGHT(light))
				visibility = pointLightVisibility(light, world_pos);
			else if(IS_SPOT_LIGHT(light))
				visibility = spotLightVisibility(light, world_pos);
			// other light types do not support shadowing

			if(visibility.x + visibility.y + visibility.z > s_min_visibility)
			{
				vec3 light_direction;
				if(IS_DIR_LIGHT(light))
					light_direction = light.direction;
				else
					light_direction = normalize(light.position - world_pos);

				vec3 cam_to_pos = normalize(u_cam_pos - world_pos);
				float contribution = distance_fade * phaseFunction(cam_to_pos, -light_direction, u_fog_anisotropy);

				switch(GET_LIGHT_TYPE(light))
				{
				case LIGHT_TYPE_POINT:
					contribution *= samplePointLight(light, world_pos, distance_sq);
					break;

				case LIGHT_TYPE_SPOT:
					contribution *= sampleSpotLight(light, world_pos, distance_sq, thickness);
					break;

				case LIGHT_TYPE_AREA:
					contribution *= sampleAreaLight(light, world_pos, distance_sq);
					break;

				case LIGHT_TYPE_TUBE:
					// TODO: calculate the amount of energy at 'world_pos'
					break;

				case LIGHT_TYPE_SPHERE:
					// TODO: calculate the amount of energy at 'world_pos'
					break;

				case LIGHT_TYPE_DISC:
					// TODO: calculate the amount of energy at 'world_pos'
					break;
				}

				if(contribution > s_min_contribution)
				{
					// contribution = min(contribution, light.intensity * 5e-3);
		        	scatter_contrib = contribution
											* light.color
											* light.intensity
											* light.fog_intensity;
				}
			}
		}

        total_scattered += scatter_contrib;
	}

	float density = u_fog_density; // TODO: noise texture?
	total_scattered *= density;

	if(u_fog_noise)
	{
		float noise_density = perlinNoise((world_pos + u_fog_noise_offset) * u_fog_noise_frequency);
		noise_density = noise_density * 0.5 + 0.5;  // -> [ 0, 1 ]
		total_scattered *= noise_density;
		// absorption *= density;
	}

	if(u_froxel_blend_previous)
	{
		// same as above, but without noise
		vec3 world_pos = froxelWorldPos(froxel, u_froxel_zexp, u_inv_view_projection);

		// find the corresponding UV in the previous froxel grid
		vec3 prev_uv = worldToUV(world_pos, u_prev_view);
		// reject UV outside the froxel grid (looks better with temporal blending)
		if(all(greaterThanEqual(prev_uv, vec3(0))) && all(lessThanEqual(prev_uv, vec3(1))))
		{
			// sample previous froxel
			vec3 prev_scattered = textureLod(u_prev_scatter, prev_uv, 0).rgb;
			total_scattered = mix(total_scattered, prev_scattered, u_froxel_blend_weight);
		}
	}

	imageStore(u_out_scatter, froxel, vec4(total_scattered, density));
}

float samplePointLight(GPULight light, vec3 world_pos, float distance_sq)
{
	return fogDistanceFalloff(sqrt(distance_sq), light.affect_radius);
}

float coneDistanceWithDiameter(GPULight spot, float diameter);

float sampleSpotLight(GPULight light, vec3 world_pos, float distance_sq, float slice_thickness)
{
	float center_distance = sqrt(distance_sq);

	float energy;

	/*
	NOTE: this is an attempt at sub-sampling near the spot light apex.
	      it's not correct.

	const float sub_sample_below_width = 0.5f;  // in world-space units
	const uint sub_sample_max = 3;   // on either side of the center sample

	uint num_samples = 0;
	float multiSampleDistance = coneDistanceWithDiameter(light, sub_sample_below_width);
	if(distance_sq < multiSampleDistance*multiSampleDistance)
		num_samples = computeSpotNumSamples(world_pos, light, sub_sample_below_width, sub_sample_max);
	if(num_samples > 0)
	{
		num_samples = 3;
		// weights: depending on the number of samples, all weight should total = 1
		const float weights[3 + 5 + 7] = {
			// num_samples == 1
			0.25,
			0.50,   // center
			0.25,
			// num_samples == 2
			0.12007838424321347,
			0.2338807565853503,
			0.29208171834287244,  // center
			0.2338807565853503,
			0.12007838424321347,
			// num_samples == 3
		 	0.07015932695902607,
			0.131074878967366,
			0.19071282356963737,
			0.21610594100794114,  // center
			0.19071282356963737,
			0.131074878967366,
		 	0.07015932695902607,
		};
		const uint sample_offset[3] = { 0, 3, 8 };

		// linear spacing... could also use exponential
		vec3 to_froxel = world_pos - u_cam_pos;
		vec3 sample_stride = normalize(to_froxel) * (slice_thickness / 2) / float(num_samples + 1);
		float center_distance = sqrt(distance_sq);
		float stride_distance = 0;//(slice_thickness / 2) / float(num_samples + 1);

		float distance = center_distance - float(num_samples)*stride_distance;

		uint weight_idx = sample_offset[num_samples - 1];

		if(num_samples >= 1)
		{
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
		}
		if(num_samples >= 2)
		{
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
		}
		if(num_samples >= 3)
		{
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
			distance += stride_distance;
			energy += fogDistanceFalloff(distance, light.affect_radius) * weights[weight_idx++];
		}
	}
	else
	*/
	// just the center sample
	energy = fogDistanceFalloff(center_distance, light.affect_radius);

	vec3 light_to_froxel = world_pos - light.position;
	energy *= getSpotAngleAttenuation(normalize(light_to_froxel), light.direction, light.outer_angle, light.inner_angle);
	energy *= sin(light.outer_angle); // or something like it

 	float dist_fraction = distance_sq / (light.affect_radius*light.affect_radius);
	// TODO: cut off at a specific diameter
	float cutoff_point = coneDistanceWithDiameter(light, 0.5);
	cutoff_point *= cutoff_point;
	cutoff_point /= light.affect_radius*light.affect_radius;
   	energy *= smoothstep(0.f, cutoff_point, dist_fraction);

	return energy;
}

float sampleAreaLight(GPULight light, vec3 sample_pos, float distance_sq)
{
	vec3 shape_cross = cross(light.shape_points[1].xyz - light.shape_points[0].xyz,
                 			 light.shape_points[3].xyz - light.shape_points[0].xyz);
	vec3 normal = normalize(shape_cross);

	vec3 to_sample = sample_pos - light.position;
	float dist = sqrt(distance_sq);
	vec3 dir = to_sample / max(dist, 1e-6);

	// rough estimate of projected solid angle;
	// average distance from sample to four corners
	float avg_d = 0;
	for(int i = 0; i < 4; ++i)
	    avg_d += length(light.shape_points[i].xyz - sample_pos);
	avg_d *= 0.25;

	float area_scale = (light.affect_radius * light.affect_radius) / (avg_d * avg_d + 1e-6);

	// simple Lambert term to fade off-axis contributions
	float n_dot_l = dot(normal, dir);

	if(IS_DOUBLE_SIDED(light))
	{
		n_dot_l = abs(n_dot_l);
		area_scale *= 0.5;
	}
	n_dot_l = max(n_dot_l, 0);

	// Basic distance attenuation with controllable falloff
	float falloff = fogDistanceFalloff(dist, light.affect_radius);

	return n_dot_l * falloff * area_scale / 100;
}

float froxelThickness(int z)
{
    return exp(-float(FROXEL_GRID_D - z - 1) / float(FROXEL_GRID_D));
}

float linear_01_to_exp_01_depth(float z)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1 - z_buffer_params_y;

    return (1 / z - z_buffer_params_y) / z_buffer_params_x;
}

vec3 uvToNDC(vec3 uv, float depth_exp)
{
    vec3 ndc;

    ndc.x = 2 * uv.x - 1;
    ndc.y = 2 * uv.y - 1;
    ndc.z = 2 * linear_01_to_exp_01_depth(uv.z) - 1;

    return ndc;
}

vec3 ndcToWorldPos(vec3 ndc, mat4 inv_vp)
{
    vec4 p = inv_vp * vec4(ndc, 1);

    p.x /= p.w;
    p.y /= p.w;
    p.z /= p.w;

    return p.xyz;
}

vec3 froxelUV(ivec3 froxel, float noise)
{
    // Exponential View-Z
    float view_z = u_near_z * pow(u_far_z / u_near_z, (float(froxel.z) + 0.5 + noise) / float(FROXEL_GRID_D));

    // float z_norm = log(view_z / u_near_z) /
    //                log(u_far_z / u_near_z);

    return vec3((float(froxel.x) + 0.5) / float(FROXEL_GRID_W),
                (float(froxel.y) + 0.5) / float(FROXEL_GRID_H),
                view_z / u_far_z);
}

vec3 froxelUV(ivec3 froxel)
{
	return froxelUV(froxel, 0);
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj, vec3 noise)
{
    vec3 uv = froxelUV(froxel, noise.z);
    vec3 ndc = uvToNDC(uv, depth_exp);
    return ndcToWorldPos(ndc, inv_view_proj) + vec3(noise.xy/vec2(tile_grid)/4, 0);
}

vec3 froxelWorldPos(ivec3 froxel, float depth_exp, mat4 inv_view_proj)
{
	return froxelWorldPos(froxel, depth_exp, inv_view_proj, vec3(0));
}

float sampleBlueNoise(ivec3 coord)
{
	int noiseSize = textureSize(u_blue_noise, 0).x;
    ivec2 noise_coord = (coord.xy + ivec2(0, 1) * coord.z * noiseSize) % noiseSize;
    return texelFetch(u_blue_noise, noise_coord, 0).r;
}

float phaseFunction(vec3 Wo, vec3 Wi, float g)
{
	float cos_theta = dot(Wo, Wi);
    float denom     = 1 + g * g + 2 * g * cos_theta;
    return (1 / (4 * PI)) * (1 - g * g) / max(pow(denom, 1.5f), 1e-4);
}

float exp_to_linear_depth(float z, float n, float f)
{
    float z_buffer_params_y = u_far_z / u_near_z;
    float z_buffer_params_x = 1.0f - z_buffer_params_y;

    return 1 / (z_buffer_params_x * z + z_buffer_params_y);
}

vec3 ndcToUV(vec3 ndc, float depth_power)
{
    vec3 uv;

    uv.x = ndc.x * 0.5f + 0.5f;
    uv.y = ndc.y * 0.5f + 0.5f;
    uv.z = exp_to_linear_depth(ndc.z * 0.5f + 0.5f, u_near_z, u_far_z);

    // Exponential View-Z
    vec2 params = vec2(float(FROXEL_GRID_D) / log2(u_far_z / u_near_z), -(float(FROXEL_GRID_D) * log2(u_near_z) / log2(u_far_z / u_near_z)));

    float view_z = uv.z * u_far_z;
    uv.z = (max(log2(view_z) * params.x + params.y, 0)) / FROXEL_GRID_D;

    return uv;
}

vec3 worldToNDC(vec3 world_pos, mat4 view_proj)
{
    vec4 p = view_proj * vec4(world_pos, 1);

    if (p.w > 0)
    {
        p.x /= p.w;
        p.y /= p.w;
        p.z /= p.w;
    }

    return p.xyz;
}

vec3 worldToUV(vec3 world_pos, mat4 view)
{
    vec3 ndc = worldToNDC(world_pos, u_projection * view);
    return ndcToUV(ndc, u_froxel_zexp);
}

vec3 worldToFroxelUV(vec3 world_pos, mat4 view)
{
    // Transform into *view space*
    vec4 view_pos = view * vec4(world_pos, 1);

    // Perspective divide not needed (weâ€™re in view space now)
    // u_cam_pos.z is negative in standard right-handed OpenGL camera space.
    float view_z = -view_pos.z;

    // --- X/Y mapping ---
    // Project to NDC
    vec4 clip_pos = u_projection * view_pos;
    vec3 ndc = clip_pos.xyz / clip_pos.w;   // [ -1, 1 ]

    // Map to [0,1]
    // float u = ndc.x * 0.5 + 0.5;
    // float v = ndc.y * 0.5 + 0.5;
    vec2 uv = (ndc * 0.5 + 0.5).xy;

    // --- Z mapping ---
    // Match your exponential partitioning
    // normalize viewZ against far
    float w = log(view_z / u_near_z) / log(u_far_z / u_near_z);

    return vec3(uv, clamp(w, 0, 1));
}

float fogDistanceFalloff(float distance, float light_radius)
{
	return 1 - pow(distance / light_radius, u_falloff_power);
	// TODO: try:  seems worse?
	// return 1 / (1 + pow(distance / light_radius, u_falloff_power));
}

// from pbr_scatter_contrib.glh (slightly modified)
float getSquareFalloffAttenuation(float distance_sq, float light_radius_squared)
{
    // float distance_square = dot(pos_to_light, pos_to_light);
    float factor          = distance_sq / light_radius_squared;
    float smooth_factor   = max(1.0 - factor * factor, 0.0);

    return (smooth_factor * smooth_factor) / max(distance_sq, 1e-5);
}

// TODO: combine these two functions?
float getSpotSquareFalloffAttenuation(float distance_sq, float light_radius_sq)
{
    // float distance_square = dot(pos_to_light, pos_to_light);
    float factor          = distance_sq / light_radius_sq;
    float smooth_factor   = max(1.0 - factor * factor, 0.0);

    // minimize the "warbling wasp stinger" by fading out near the apex
    float dist_fraction = distance_sq / light_radius_sq;
   	smooth_factor *= smoothstep(0.f, 0.01f, dist_fraction);

    return (smooth_factor * smooth_factor) / max(distance_sq, 1e-5);
}

float getSpotAngleAttenuation(vec3 to_light, vec3 spot_dir, float outer_angle, float inner_angle)
{
    // the scale and offset computations can be done CPU-side
    float cos_outer   = cos(outer_angle);

    float spot_scale  = 1.0 / max(cos(inner_angle) - cos_outer, 1e-5);
    float spot_offset = -cos_outer * spot_scale;

    float cd          = dot(spot_dir, to_light);
    float attenuation = clamp(cd * spot_scale + spot_offset, 0.0, 1.0);

    return attenuation * attenuation;
}

float sampleShadow(float current_depth, vec2 atlas_uv)
{
	float sample_depth = textureLod(u_shadow_atlas_single, atlas_uv, 0).r;
 	return current_depth > sample_depth ? 0 : 1;
}

float fadeLightByDistance(GPULight light)
{
	float light_edge_distance = max(0, distance(light.position, u_cam_pos) - light.affect_radius);
	// fade the whole light by distance
	return fadeByDistance(light_edge_distance, u_light_max_distance);
}

vec2 calculateShadowUV(vec3 world_pos, mat4 view_proj, vec4 rect, out vec4 rect_uv);
float shadowVisibility(vec3 light_to_frag, vec3 world_pos, GPULight light, mat4 view_proj, vec4 rect);
float sampleShadow(float distance, float normalized_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max);

vec3 pointLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	vec3 light_to_frag = world_pos - light.position;

	mat4 view_proj;
	vec4 rect; // shadow slot rectangle in atlas, in absolute pixels
	detectCubeFaceSlot(light_to_frag, slot_info, view_proj, rect);

	float shadow_visibility = shadowVisibility(light_to_frag, world_pos, light, view_proj, rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

vec3 spotLightVisibility(GPULight light, vec3 world_pos)
{
	float light_fade = fadeLightByDistance(light);
	if(light_fade == 0)
		return vec3(0);

	if(! IS_SHADOW_CASTER(light))
		return vec3(light_fade);

	uint shadow_idx = GET_SHADOW_IDX(light);
	if(shadow_idx == LIGHT_NO_SHADOW)
		return vec3(light_fade);  // no shadow map in use

	// fade the shadow sample by distance
	float camera_distance = distance(world_pos, u_cam_pos);
	float shadow_fade = fadeByDistance(camera_distance, u_shadow_max_distance);
	if(shadow_fade == 0)
		return vec3(light_fade);

	ShadowSlotInfo slot_info = ssbo_shadow_slots[shadow_idx];

	mat4 view_proj = slot_info.view_proj[0];
	vec4 rect = slot_info.atlas_rect[0];

	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(world_pos, view_proj, rect, rect_uv);

	vec3 light_to_frag = world_pos - light.position;
	float shadow_visibility = shadowVisibility(light_to_frag, world_pos, light, view_proj, rect);

	float shadow_faded = 1 - (1 - shadow_visibility) * shadow_fade;
	float visible = light_fade * shadow_faded;

	return vec3(visible);
}

float sampleShadow(float current_depth, vec2 atlas_uv, vec2 uv_min, vec2 uv_max)
{
	return texture(u_shadow_atlas_single, atlas_uv).r > current_depth? 1: 0;
}

float shadowVisibility(vec3 light_to_frag, vec3 world_pos, GPULight light, mat4 view_proj, vec4 rect)
{
	vec4 rect_uv;
	vec2 atlas_uv = calculateShadowUV(world_pos, view_proj, rect, rect_uv);

	float light_distance = length(light_to_frag);
	float normalized_depth = light_distance / light.affect_radius;

	vec2 uv_min = rect_uv.xy;
	vec2 uv_max = rect_uv.xy + rect_uv.zw - shadow_atlas_texel_size;
	return sampleShadow(normalized_depth, atlas_uv, uv_min, uv_max);
}

const float SOFT_DISTANCE_LIMIT = 0.8; // fraction of hard limit

float fadeByDistance(float distance, float hard_limit)
{
	return 1 - smoothstep(hard_limit*SOFT_DISTANCE_LIMIT, hard_limit, distance);
}

float coneDiameterAtPoint(vec3 world_pos, GPULight spot)
{
    float axialDist = dot(world_pos - spot.position, spot.direction);
    axialDist = max(axialDist, 0.0); // only forward of apex

    float tanHalf = tan(spot.outer_angle);
    return 2 * axialDist * tanHalf;
}

float coneDistanceWithDiameter(GPULight spot, float diameter)
{
	return diameter / (2*tan(spot.outer_angle));
}

uint computeSpotNumSamples(
    vec3 world_pos,    // the candidate sample position (within the froxel)
    GPULight spot,
    float maxWidth,    // width that maps to full up-sampling
    uint  maxSamples   // max sample count (e.g. 4)
)
{
	const float minWidth = 0;    // width threshold where we start to up-sample

	float w = coneDiameterAtPoint(world_pos, spot);
    if(w <= minWidth)
    	return 0;

    // viewFactor: 0 = looking exactly down cone, 1 = side-on
    vec3 viewDir = normalize(u_cam_pos - world_pos);
    float cosView = dot(viewDir, normalize(spot.direction));
    float viewFactor = 1 - abs(cosView);

    // map width to [0..1]
    float t = clamp((w - minWidth) / max(1e-6, maxWidth - minWidth), 0, 1);
    float importance = t * viewFactor; // weighing both width and viewing angle

    float fcount = 1 + importance * float(maxSamples - 1);
    return int(max(1, floor(fcount + 0.5f)));
}
