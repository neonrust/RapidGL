#version 460 core

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "shapes.glh"

#define THREADS_COUNT 128

layout(local_size_x = THREADS_COUNT, local_size_y = 1, local_size_z = 1) in;


layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

SSBO_RELEVANT_LIGHTS_INDEX_ro;

layout(std430, binding = SSBO_BIND_ALL_VOLUMETRIC_LIGHTS_INDEX) writeonly buffer VolLightsSSBO
{
	uint ssbo_num_volumetric_lights;
	uint ssbo_volumetric_lights_index[];
};

uniform float u_volumetric_max_distance;
uniform vec3 u_cam_pos;


bool frustum_intersect(Sphere sphere);

void main()
{
	for (uint index = gl_LocalInvocationIndex; index < ssbo_relevant_lights_index.length(); index += THREADS_COUNT)
	{
		uint light_index = ssbo_relevant_lights_index[index];
		GPULight L = ssbo_lights[light_index];

		if(! IS_VOLUMETRIC(L))
			continue;

		bool add_light = false;

		if(IS_DIR_LIGHT(L))
			add_light = true;
		else
		{
			vec3 sphere_center = L.position;
			float sphere_radius = L.affect_radius;
			if(IS_SPOT_LIGHT(L))
			{
				sphere_center += L.direction * L.spot_bounds_radius;
				sphere_radius = L.spot_bounds_radius;
			}

			float edge_distance = distance(sphere_center, u_cam_pos) - sphere_radius;

			add_light = edge_distance < u_volumetric_max_distance;
		}

		if(add_light)
		{
			uint out_index = atomicAdd(ssbo_num_volumetric_lights, 1);
			ssbo_volumetric_lights_index[out_index] = light_index;
		}
	}
}
