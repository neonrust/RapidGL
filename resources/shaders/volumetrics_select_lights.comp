#version 460 core

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "shapes.glh"

#define THREADS_COUNT 128

layout(local_size_x = THREADS_COUNT, local_size_y = 1, local_size_z = 1) in;

SSBO_RELEVANT_LIGHTS_INDEX_ro;

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_ALL_VOLUMETRIC_LIGHTS_INDEX) writeonly buffer VolLightsSSBO
{
	uint ssbo_num_volumetric_lights;
	uint ssbo_volumetric_lights_index[];
};

uniform vec4 u_frustum_planes[6];  // xyz = normal, w = offset

bool frustumIntersect(Sphere sphere);

void main()
{
	for (uint index = gl_LocalInvocationIndex; index < ssbo_relevant_lights_index.length(); index += THREADS_COUNT)
	{
		uint light_index = ssbo_relevant_lights_index[index];
		GPULight L = ssbo_lights[light_index];

		if(! IS_VOLUMETRIC(L))
			continue;

		bool add_light = false;

		if(IS_DIR_LIGHT(L))
			add_light = true;
		else
		{
			vec3 sphere_center = L.position;
			float sphere_radius = L.affect_radius;
			if(IS_SPOT_LIGHT(L))
			{
				sphere_center += L.direction * L.spot_bounds_radius;
				sphere_radius = L.spot_bounds_radius;
			}

			add_light = frustumIntersect(Sphere(sphere_center, sphere_radius));
		}

		if(add_light)
		{
			uint out_index = atomicAdd(ssbo_num_volumetric_lights, 1);
			ssbo_volumetric_lights_index[out_index] = light_index;
		}
	}
}

bool frustumIntersect(Sphere sphere)
{
    for(uint idx = 0; idx < 6; ++idx)
    {
        vec4 plane = u_frustum_planes[idx];  // normal, offset
        float dist = dot(plane.xyz, sphere.center) + plane.w;
        if(dist < -sphere.radius) // behind the plane (i.e. outside the frustum)
            return false;
    }
    return true;
}
