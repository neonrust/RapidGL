#version 460 core

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "shapes.glh"
#include "frustum.glh"

#define THREADS_COUNT 128

layout(local_size_x = THREADS_COUNT, local_size_y = 1, local_size_z = 1) in;

SSBO_RELEVANT_LIGHTS_INDEX_ro;

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_ALL_VOLUMETRIC_LIGHTS_INDEX) writeonly buffer VolLightsSSBO
{
	uint ssbo_num_volumetric_lights;
	uint ssbo_volumetric_lights_index[];
};

uniform vec4 u_frustum_planes[6];  // xyz = normal, w = offset

bool frustum_intersect(Sphere sphere);

void main()
{
	for (uint index = gl_LocalInvocationIndex; index < ssbo_relevant_lights_index.length(); index += THREADS_COUNT)
	{
		uint light_index = ssbo_relevant_lights_index[index];
		GPULight L = ssbo_lights[light_index];

		if(! IS_VOLUMETRIC(L))
			continue;

		bool add_light = false;

		if(IS_DIR_LIGHT(L))
			add_light = true;
		else
		{
			Sphere sphere;
			sphere.center = L.position;
			sphere.radius = L.affect_radius;
			if(IS_SPOT_LIGHT(L))
			{
				sphere.center += L.direction * L.spot_bounds_radius;
				sphere.radius = L.spot_bounds_radius;
			}

			add_light = frustum_intersect(sphere);
		}

		if(add_light)
		{
			uint out_index = atomicAdd(ssbo_num_volumetric_lights, 1);
			ssbo_volumetric_lights_index[out_index] = light_index;
		}
	}
}

bool frustum_intersect(Sphere sphere)
{
	// TODO: might get false positives, e.g. large spheres at the right position
	// https://wickedengine.net/2018/01/optimizing-tile-based-light-culling/
	// https://gamedev.stackexchange.com/a/86010

    for(uint idx = 0; idx < 6; ++idx)
    {
        vec4 plane_eq = u_frustum_planes[idx];  // normal, offset
        Plane plane = Plane(plane_eq.xyz, plane_eq.w);
        if(! plane_facing(plane, sphere))
           	return false;
    }
    return true;
}
