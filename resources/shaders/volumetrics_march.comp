#version 460 core

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "volumetrics.glh"

#define GROUP_SIZE_X 8
#define GROUP_SIZE_Y 8
#define GROUP_SIZE_Z 1

#define MARCH_STEPS 128
#define M_PI 3.14159265359

layout(local_size_x = GROUP_SIZE_X, local_size_y = GROUP_SIZE_Y, local_size_z = GROUP_SIZE_Z) in;

uniform float u_effect_scale;
uniform float u_near_z;
uniform float u_far_z;
uniform mat4  u_projection;

layout(binding = 5)          uniform           sampler3D u_input_scatter;
layout(binding = 2)          uniform           sampler2D u_input_depth;
layout(binding = 1, rgba32f) uniform writeonly image2D   u_output_volumetrics;

const float s_min_thickness = 0.001;

vec2 froxel_depth_edges(int z);
float froxel_distance(int z);
float depthbuffer_to_view_z(float depth, mat4 proj);
vec4 texture_tricubic(sampler3D tex, vec3 coord);

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    vec2 depth_uv = vec2(pixel) / vec2(textureSize(u_input_depth, 0));
    float depth = texture(u_input_depth, depth_uv).r;
    float fragment_depth = depthbuffer_to_view_z(depth, u_projection);

    // if(isnan(fragment_depth) || fragment_depth == 0)
    // {
    // 	imageStore(u_output_volumetrics, pixel, vec4(10, 0, 10, 1));
    //  	return;
    // }

   	vec3 radiance = vec3(0);
	float transmittance = 1;

	for(int z = 0; z < FROXEL_GRID_D; z++)
	{
		ivec3 froxel = ivec3(pixel, z);

		vec2 depth_edges = froxel_depth_edges(z);
		float near_edge = depth_edges.x;
		float far_edge  = depth_edges.y;//min(depth_edges.y, -fragment_depth);

		float thickness = far_edge - near_edge;

		vec4 scattered_density = texelFetch(u_input_scatter, froxel, 0);
		// vec3 uv = vec3(froxel) / textureSize(u_input_scatter, 0);
		// vec4 scattered_density = texture_pcf(u_input_scatter, uv, 0);
		// vec4 scattered_density = texture_tricubic(u_input_scatter, froxel);
		vec3 scattered = scattered_density.rgb;
		float density = scattered_density.a;

		float exp_absorption = exp(-density * thickness);

		radiance += transmittance * scattered * thickness;
		transmittance *= exp_absorption;

		// if(far_edge => fragment_depth)  // we hit something!
		// 	break;
	}

	radiance *= u_effect_scale;

    imageStore(u_output_volumetrics, pixel, vec4(radiance, 1));
}

float froxel_distance(int z)
{
    return u_near_z * pow(u_far_z / u_near_z, (float(z) + 0.5f) / float(FROXEL_GRID_D));
}

vec2 froxel_depth_edges(int z)
{
    return vec2(
    	froxel_distance(z),
     	froxel_distance(z + 1)
    );
}

float depthbuffer_to_view_z(float depth, mat4 proj)
{
    // Depth buffer -> NDC
    float z_ndc = depth * 2 - 1;

    // Inverse of proj[2][2] and proj[3][2] does the trick
    float A = proj[2][2];
    float B = proj[3][2];

    // Solve clip-space projection relation: z_view = B / (z_ndc - A)
    return B / (z_ndc - A);
}
