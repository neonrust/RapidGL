#version 460 core

#define GROUP_SIZE 8

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;

#include "../../src/demos/27_clustered_shading/shaders/shared-structs.glh"
#include "volumetrics.glh"
#include "shapes.glh"
#include "frustum.glh"


layout(std430, binding = SSBO_BIND_LIGHTS)
readonly buffer LightsSSBO
{
	GPULight ssbo_lights[];
};

layout(std430, binding = SSBO_BIND_ALL_VOLUMETRIC_LIGHTS_INDEX)
readonly buffer VolLightsSSBO
{
	uint ssbo_num_volumetric_lights;
	uint ssbo_volumetric_lights_index[];
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_ALL_TILE_LIGHTS_INDEX)
writeonly buffer VolAllTileLightsIndexSSBO
{
	uint ssbo_all_tile_start_index;
	uint ssbo_all_tile_lights[]; // size = avg_lights_per_tile * num_tiles
};

layout(std430, binding = SSBO_BIND_VOLUMETRIC_TILE_LIGHTS_INDEX)
writeonly buffer VolTileLightsIndexSSBO
{
	IndexRange ssbo_tile_lights[];  // size = num_tiles
};

SSBO_RELEVANT_LIGHTS_INDEX_ro;


uniform vec3  u_frustum_corners[8];

bool intersect_frustum(Plane planes[6], Sphere sphere);
void compute_tile_frustum(ivec2 tile, out Plane planes[6]);

shared uint s_index_offset;
shared uint s_light_count;
shared uint s_affecting_lights[FROXEL_TILE_MAX_LIGHTS];

void main()
{
	if(ssbo_num_volumetric_lights == 0)
		return; // nothing for this shader to do

	const uint THREADS_COUNT = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;

	if(gl_LocalInvocationIndex == 0)
	{
		s_index_offset = 0;
		s_light_count = 0;
	}

	// tile coordinate from work group id (0 - tile_grid.x-1, 0 - tile_grid.y-1)
	ivec2 tile = ivec2(gl_WorkGroupID.xy);

	Plane frustum_planes[6];
	compute_tile_frustum(tile, frustum_planes);

	barrier();

	for(uint index = gl_LocalInvocationIndex; index < ssbo_num_volumetric_lights; index += THREADS_COUNT)
	{
		uint light_index = ssbo_volumetric_lights_index[index];
		GPULight L = ssbo_lights[light_index];

		bool is_affecting = true;

		if(! IS_DIR_LIGHT(L))
		{
			// test light's bounding sphere against the tile's frustum
			Sphere sphere;
			sphere.center = L.position;
			if(IS_SPOT_LIGHT(L))
				sphere.center += L.direction * L.spot_bounds_radius;
			sphere.radius = IS_SPOT_LIGHT(L)? L.spot_bounds_radius: L.affect_radius;  // in view space

			is_affecting = intersect_frustum(frustum_planes, sphere);
        }

		if(is_affecting)
		{
			uint next_index = atomicAdd(s_light_count, 1);
			if(next_index < FROXEL_TILE_MAX_LIGHTS)
				s_affecting_lights[next_index] = light_index;
		}
	}

	barrier();

	// write index range entry for the tile (only one thread)
	if(gl_LocalInvocationIndex == 0)// && s_light_count > 0)
	{
		uint count = min(s_light_count, FROXEL_TILE_MAX_LIGHTS);
		// reserve space ub tge gkibak kust fir tgus tuke
		uint start_offset = atomicAdd(ssbo_all_tile_start_index, count);

		for(uint idx = 0; idx < count; ++idx)
			ssbo_all_tile_lights[start_offset + idx] = s_affecting_lights[idx];

		uint tile_index = tile.y*tile_grid.x + tile.x;
		ssbo_tile_lights[tile_index] = IndexRange(start_offset, count);
	}
}

void compute_tile_frustum(ivec2 tile, out Plane planes[6])
{
	// Build per-tile frustum corners correctly.
	// u_frustum_corners[] are ordered as:
	//   0: near top left (NTL)
	//   1: near bottom left (NBL)
	//   2: far  top left (FTL)
	//   3: far  bottom left (FBL)
	//   4: near top right (NTR)
	//   5: near bottom right (NBR)
	//   6: far  top right (FTR)
	//   7: far  bottom right (FBR)
	// We must interpolate horizontally between left/right pairs first, then assign
	// the near/far and top/bottom corners for the tile.

	// not sure where the below goes wrong such that flipping of the Y axis is needed?
	tile.y = int(tile_grid.y) - 1 - tile.y;

	vec3 frustum_corners[8];

	float a0 = (float(tile.x)    ) / float(tile_grid.x);
	float a1 = (float(tile.x) + 1) / float(tile_grid.x);
	float b0 = (float(tile.y)    ) / float(tile_grid.y);
	float b1 = (float(tile.y) + 1) / float(tile_grid.y);

	// Near plane horizontal samples (top and bottom)
	vec3 near_top_a0    = mix(u_frustum_corners[0], u_frustum_corners[4], a0); // NTL -> NTR
	vec3 near_top_a1    = mix(u_frustum_corners[0], u_frustum_corners[4], a1);
	vec3 near_bottom_a0 = mix(u_frustum_corners[1], u_frustum_corners[5], a0); // NBL -> NBR
	vec3 near_bottom_a1 = mix(u_frustum_corners[1], u_frustum_corners[5], a1);
	// Far plane horizontal samples (top and bottom)
	vec3 far_top_a0     = mix(u_frustum_corners[2], u_frustum_corners[6], a0); // FTL -> FTR
	vec3 far_top_a1     = mix(u_frustum_corners[2], u_frustum_corners[6], a1);
	vec3 far_bottom_a0  = mix(u_frustum_corners[3], u_frustum_corners[7], a0); // FBL -> FBR
	vec3 far_bottom_a1  = mix(u_frustum_corners[3], u_frustum_corners[7], a1);

	// Build the four combinations per (a,b) so we interpolate horizontally (a)
	// then vertically (b). We want the corners at (a0,b0), (a0,b1), (a1,b0), (a1,b1)
	// for both near and far planes.
	vec3 near_a0_b0 = mix(near_top_a0, near_bottom_a0, b0);
	vec3 near_a0_b1 = mix(near_top_a0, near_bottom_a0, b1);
	vec3 near_a1_b0 = mix(near_top_a1, near_bottom_a1, b0);
	vec3 near_a1_b1 = mix(near_top_a1, near_bottom_a1, b1);

	vec3 far_a0_b0  = mix( far_top_a0,  far_bottom_a0, b0);
	vec3 far_a0_b1  = mix( far_top_a0,  far_bottom_a0, b1);
	vec3 far_a1_b0  = mix( far_top_a1,  far_bottom_a1, b0);
	vec3 far_a1_b1  = mix( far_top_a1,  far_bottom_a1, b1);

	// Assign in the same semantic order the rest of the shader expects:
	// 0: near top left, 1: near bottom left, 2: far top left, 3: far bottom left,
	// 4: near top right, 5: near bottom right, 6: far top right, 7: far bottom right
	frustum_corners[0] = near_a0_b0; // NTL
	frustum_corners[1] = near_a0_b1; // NBL
	frustum_corners[2] =  far_a0_b0; // FTL
	frustum_corners[3] =  far_a0_b1; // FBL
	frustum_corners[4] = near_a1_b0; // NTR
	frustum_corners[5] = near_a1_b1; // NBR
	frustum_corners[6] =  far_a1_b0; // FTR
	frustum_corners[7] =  far_a1_b1; // FBR

	// NOTE: vertex order (winding) is important, to ensure normals point inwards
	planes[0] = make_plane(frustum_corners[0], frustum_corners[1], frustum_corners[2]); // left
	planes[1] = make_plane(frustum_corners[5], frustum_corners[4], frustum_corners[6]); // right
	planes[2] = make_plane(frustum_corners[0], frustum_corners[2], frustum_corners[4]); // top
	planes[3] = make_plane(frustum_corners[1], frustum_corners[5], frustum_corners[3]); // bottom
	planes[4] = make_plane(frustum_corners[2], frustum_corners[3], frustum_corners[6]); // far
	planes[5] = make_plane(frustum_corners[0], frustum_corners[4], frustum_corners[1]); // near
}
