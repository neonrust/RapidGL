#version 460 core

#include "shared.h"

#define GROUP_SIZE 8

layout(rgba32f, binding = 0) uniform image2D   u_input_color;
layout(rgba32f, binding = 1) uniform image2D   u_output_color;
layout(binding = 2)          uniform sampler2D u_input_depth;

uniform vec3 u_fog_color;
uniform float u_fog_density;       // [ 0, 0.1 ]   (sensible)
uniform float u_fog_falloff_blend; // [ 0, 1 ]

uniform vec3  u_cam_pos;
uniform float u_near_z;
uniform float u_far_z;
uniform mat4  u_projection;
uniform mat4  u_view;
uniform mat4  u_inv_projection;
uniform mat4  u_inv_view;
uniform uvec3 u_grid_dim;
uniform uvec2 u_cluster_size_ss;
uniform float u_log_grid_dim_y;
uniform float u_ray_march_stride;

const float FOG_RADIANCE_SCALE = 0.01;
const float FOG_DISTANCE_SCALE = 0.7;  // [ 0, 1 ]

const int _RED = 1;
const int _ORANGE = 2;
const int _YELLOW = 3;
const int _GREEN = 4;
const int _CYAN = 5;
const int _BLUE = 6;
const int _PINK = 7;

struct Ray
{
	vec3 start;
	vec3 direction;
	float max_length;
};

struct Sphere
{
	vec3 center;
	float radius;
};

struct SphericalCone
{
	Sphere sphere;
	vec3 axis;
	float angle;   // radians
};

struct RayResult
{
	float dist_enter;
	float dist_closest;
	float dist_exit;
	vec3 p_enter;
	vec3 p_exit;
	vec3 p_closest;
};

struct RayConeResult
{
	float dist_enter;
	float dist_exit;
	float dist_axis; // 0 = bang-on the axis, 1 = as far away from the axis as possible (still inside the cone)

	float dist_center;
	vec3 p_enter;
	vec3 p_exit;
	int debug;
};



float atan_approx(float x);
bool solveRoots(float A, float B, float C, out float t1, out float t2);
float linearDepth(float depth);
uint computeClusterIndex(uvec3 cluster_coord);
uvec3 computeClusterCoord(vec2 screen_pos, float view_z);
float getSquareFalloffAttenuation(float distance_sq, float light_radius);
float getSpotAngleAttenuation(vec3 to_light, vec3 spot_axis, float outer_angle, float inner_angle);

// vec3 scatterLightsInCluster(Ray eye_ray, uvec3 cluster_coord, float max_depth);

vec3 scatterPointLight(Ray ray, PointLight light);
vec3 scatterSpotLight(Ray ray, SpotLight light);
bool isPointInsideCone(vec3 point, SphericalCone cone);

bool testRaySphere(Ray ray, Sphere sphere, out RayResult result);
bool testRayCone(Ray ray, SphericalCone cone, out RayResult result);
bool testRaySphereCap(Ray ray, SphericalCone cone, bool startInside, out RayResult result);
vec3 rayPoint(Ray ray, float fraction);
void rayRayDistance(Ray ray1, Ray ray2, out RayResult result);
float rayPointDistance(Ray ray, vec3 point, out float ray_dist);
float vectorVectorAngle(vec3 v1_norm, vec3 v2_norm);

float depthWorldSpaceDistance(vec2 texCoord, float depth)
{
    vec4 pos = vec4(texCoord*2 - 1, depth, 1);
    vec4 viewPos = u_inv_projection * pos;
    viewPos /= viewPos.w;

	return length(viewPos.xyz);
}

layout(std430, binding = POINT_LIGHTS_SSBO_BINDING_INDEX) buffer PointLightSSBO
{
    PointLight point_lights[];
};

layout(std430, binding = SPOT_LIGHTS_SSBO_BINDING_INDEX) buffer SpotLightsSSBO
{
    SpotLight spot_lights[];
};


layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;
void main()
{
	vec2 screen_size = vec2(imageSize(u_input_color));
	uvec2 pixel_id   = gl_GlobalInvocationID.xy;


	// draw "aiming dot" at the center of the screen
	// this should not be in the final version!  ;)
	ivec2 vec_to_enter = ivec2(int(pixel_id.x) - screen_size.x/2, int(pixel_id.y) - screen_size.y/2);
	float distance_from_center = dot(vec_to_enter, vec_to_enter);
	if(distance_from_center < 8)
	{
		imageStore(u_output_color, ivec2(pixel_id), vec4(10, 10, 10, 1));
		return;
	}



	// skip invocations that operate outside the screen
	if(pixel_id.x >= screen_size.x || pixel_id.y >= screen_size.y)
		return;

	vec2 screen_pos  = vec2(pixel_id) + vec2(0.5); // pointing at the center of each pixel
	vec2 screen_norm = (screen_pos*2 - vec2(screen_size)) / vec2(screen_size); // [ -1, 1 ]
	vec2 screen_uv = screen_pos/screen_size;

	float view_z     = texture(u_input_depth, screen_uv).r;
	// float frag_depth = linearDepth(view_z);
	float frag_dist = depthWorldSpaceDistance(screen_uv, view_z);

	// camera-space
	vec4 target = u_inv_projection * vec4(screen_norm, 1, 1); // camera-space
	vec3 direction_cs = normalize(target.xyz / target.w);
	// world-space
	Ray eye_ray;
	eye_ray.start = u_cam_pos;
	eye_ray.direction = vec3(u_inv_view * vec4(direction_cs, 0));
	eye_ray.max_length = frag_dist;


	vec3 fog_radiance = vec3(0);

	// for(int idx = 0; idx < point_lights.length(); ++idx)
	// 	fog_radiance += scatterPointLight(eye_ray, point_lights[idx]);

	for(int idx = 0; idx < spot_lights.length(); ++idx)
		fog_radiance += scatterSpotLight(eye_ray, spot_lights[idx]);




	if(point_lights.length() == 0 && pixel_id.x < 45 && pixel_id.y < 50)
		fog_radiance += vec3(1, 0, 0);
	if(spot_lights.length() == 0 && pixel_id.x >= 55 && pixel_id.x < 100 && pixel_id.y < 50)
		fog_radiance += vec3(1, 0, 0);

	// TODO: area lights
	//   I guess area light scattering could be approximated using a frustum (the shape, i.e. a cropped pyramid),
	//   with fall of in X and Y (from the center, outwards) as well as in Z (from the source outwards)
	//    (in light-space, naturally).
	//    Here's a daring 2d representation:
	//                   ___----
	//         ___---****    *
	//        |              |  fall off from center axis
	//      C |------------------> center (falling off from C)
	//        |___           |  fall-off from center axis
	//            ***----___ v
	//                      ****
	// Are the angle of the frustum sides always the same or a function of the width/height (on that axis) ?
	// If the latter, probably with a sqrt-like curvature, increasing fast in the beginning,
	// then asymptotically reaching a "max" angle (maybe 70-90 degrees?)
	// Pr maybe both width & height contribute to that curve?


/*
	// TODO: perform scattering per screen tile (frustlet)
	for(uint cluster_index = 0; cluster_index < u_grid_dim.x * u_grid_dim.y; ++cluster_index)
		fog_radiance += scatterLightsInCluster(eye_ray, cluster_index, frag_depth);
*/

	vec4 src_color = imageLoad(u_input_color, ivec2(screen_pos));
	vec4 final_color = vec4(src_color.rgb + fog_radiance, 1);

	final_color = vec4(clamp(final_color.rgb, vec3(0), vec3(1000)), 1);

	imageStore(u_output_color, ivec2(screen_pos), final_color);
}

// vec3 scatterLightsInCluster(Ray eye_ray, uvec3 cluster_coord, float frag_depth)
// {
// 	uint cluster_index = computeClusterIndex(cluster_coord);

// 	 // Calculate the point lights contribution
//    	uint light_index_offset = point_light_grid[cluster_index].offset;
//     uint light_count = point_light_grid[cluster_index].count;

// 	vec3 radiance = vec3(0);

//     for (uint i = 0; i < light_count; ++i)
//     {
//         uint light_index = point_light_index_list[light_index_offset + i];
// 		PointLight light = point_lights[light_index];

// 		radiance += scatterPointLight(eye_ray, light);
// 	}

// 	return radiance;
// }

vec3 scatterPointLight(Ray ray, PointLight light)
{
	vec3 radiance = vec3(0);

	Sphere light_sphere;
	light_sphere.center = light.position;
	light_sphere.radius = light.radius;

	RayResult result;
	if(testRaySphere(ray, light_sphere, result))
	{
		// clamping like this isn't strictly correct (doesn't take the projection into account)
		float t1 = clamp(result.dist_enter, 0, ray.max_length);
		float t2 = clamp(result.dist_exit, t1, ray.max_length);
		float t_closest = clamp(result.dist_closest, t1, t2);

		vec3 point_closest = rayPoint(ray, t_closest);
		vec3 closest_to_light = point_closest - light.position;

		// NOTE: linear fall off actually looks a bit nicer (subjectively)  ;)
		//   squared fall off is better but also produces a very bright center...
		float d = length(closest_to_light)/FOG_DISTANCE_SCALE;

		float attenuation_lin = 1 - d/light.radius;
		float attenuation_sq = getSquareFalloffAttenuation(dot(closest_to_light, closest_to_light), light.radius*light.radius);
		float attenuation = mix(attenuation_lin, attenuation_sq, u_fog_falloff_blend);

		float energy = light.base.intensity * attenuation;
		float thickness = t2 - t1;
		float fog_energy = energy * thickness;
		// TODO: could also sample a 3d texture using a line through t1 and t2
		radiance += fog_energy * u_fog_density * light.base.color * u_fog_color * FOG_RADIANCE_SCALE;
	}

	return max(vec3(0), radiance);
}

vec3 sampleSpot(SpotLight spot, vec3 point);

vec3 scatterSpotLight(Ray ray, SpotLight spot)
{
	SphericalCone outer_cone;
	outer_cone.sphere.center  = spot.point.position;
	outer_cone.sphere.radius  = spot.point.radius;
	outer_cone.axis           = spot.direction;
	outer_cone.angle          = spot.outer_angle;

	RayResult result;
	if(! testRayCone(ray, outer_cone, result))
		return vec3(0);  // missed the entire cone

	float cone_enter = min(result.dist_enter, ray.max_length);
	float cone_exit = min(result.dist_exit, ray.max_length);

	// TODO: perform raymarching between 'cone_enter' & 'cone_exit' in X steps
	//   and accumulate the irradiance along the way (integrating, really)
	//   can probably scale the number of steps by how far apart tenter & exit are.
	//   and by how far away from the camera it is. (and a global step count scale, naturally)
	// OR is it possible to build a "curve" of the brightness along the ray, and integrate that?
	//   hm, maybe that will result in the same thing... ;)

	vec3 radiance = vec3(0);

	// TODO: compute number of steps based on fixed step size
	const int numSteps = int(ceil((cone_exit - cone_enter)/u_ray_march_stride));
	vec3 stride = ray.direction * u_ray_march_stride;

	// start point
	vec3 p_sample = rayPoint(ray, cone_enter);

	for(int step = 0; step < numSteps; ++step)
	{
		radiance += sampleSpot(spot, p_sample)/float(numSteps);
		// TODO: apply 3d noise (at 'p_sample')
		p_sample += stride;
	}

	return radiance * u_fog_color * u_fog_density * spot.point.base.color;
}

vec3 sampleSpot(SpotLight spot, vec3 point)
{
	vec3 to_point = point - spot.point.position;
	float center_distance_sq =  dot(to_point, to_point);

	float dummy;
	float ray_dist = rayPointDistance(Ray(spot.point.position, spot.direction, 0), point, dummy);
	float axis_distance_sq = ray_dist*ray_dist;

	float atten_center = getSquareFalloffAttenuation(center_distance_sq, spot.point.radius*spot.point.radius);
	float atten_axis = 1;//getSpotAngleAttenuation(normalize(to_point), spot.direction, spot.outer_angle, spot.inner_angle);

	return vec3(spot.point.base.intensity * atten_center * atten_axis);
}

float atan_approx(float x)
{
    return (1.570796 * x) / (1.0 + abs(x));
}


uint computeClusterIndex(uvec3 cluster_coord)
{
    return cluster_coord.x + (u_grid_dim.x * (cluster_coord.y + u_grid_dim.y * cluster_coord.z));
}

uvec3 computeClusterCoord(vec2 screen_pos, float view_z)
{
    uint x = uint(screen_pos.x / u_cluster_size_ss.x);
	uint y = uint(screen_pos.y / u_cluster_size_ss.y);
	uint z = uint(log(view_z / u_near_z) * u_log_grid_dim_y);

    return uvec3(x, y, z);
}


float linearDepth(float depth)
{
	// convert a depth texture sample in range (-1, 1) to linear depth, ranged (near_z, far_z).
	float ndc          = depth * 2.0 - 1.0;
	float linear_depth = 2.0 * u_near_z * u_far_z / (u_far_z + u_near_z - ndc * (u_far_z - u_near_z));

	return linear_depth;
}

bool testRaySphere(Ray ray, Sphere sphere, out RayResult result)
{
	vec3 center_to_ray = ray.start - sphere.center;

	float A = dot(ray.direction, ray.direction);
	float B = 2 * dot(center_to_ray, ray.direction);
	float C = dot(center_to_ray, center_to_ray) - sphere.radius*sphere.radius;

	float t1;
	float t2;
	if(! solveRoots(A, B, C, t1, t2))
		return false;

	result.dist_enter = t1;
	result.dist_exit  = t2;
	result.dist_closest = (t1 + t2)/2; // aka -B/2A

	result.p_enter = rayPoint(ray, result.dist_enter);
	result.p_exit = rayPoint(ray, result.dist_exit);
	result.p_closest = rayPoint(ray, result.dist_closest);

	return true;
}

bool testRayCone(Ray ray, SphericalCone cone, out RayResult result)
{
	vec3 center_to_ray = ray.start - cone.sphere.center; // aka CO

	float start_distance_sq = dot(center_to_ray, center_to_ray);

	// check wherther ray starts inside the cone (sphere & cone surface)
	bool startInside = start_distance_sq < cone.sphere.radius*cone.sphere.radius \
		&& (dot(center_to_ray, cone.axis) / length(center_to_ray)) >= cos(cone.angle);  // inside the cone surface

	// optimization: check if the ray will miss the sphere entirely
	// float t_closest = dot(center_to_ray, cone.axis);
	// vec3 p_closest_to_center = rayPoint(ray, t_closest);
	// vec3 closest_to_center = p_closest_to_center - cone.sphere.center;
	// float distance_sq = dot(closest_to_center, closest_to_center);
	// if(distance_sq > cone.sphere.radius*cone.sphere.radius)
	// 	return false;


	// check intersection with the infinite cone
	float cos_theta = cos(cone.angle);
	float cos_theta_sq = cos_theta*cos_theta;
	float dir_axis_dot = dot(ray.direction, cone.axis);
	float CO_axis_dot = dot(center_to_ray, cone.axis);

	float A = dir_axis_dot*dir_axis_dot - cos_theta_sq;
	float B = 2 * (dir_axis_dot*CO_axis_dot - dot(ray.direction, center_to_ray)*cos_theta_sq);
	float C = CO_axis_dot*CO_axis_dot - start_distance_sq*cos_theta_sq;

	float t1;
	float t2;
	t1 = -1;
	t2 = -1;

	if(! solveRoots(A, B, C, t1, t2))
		return false;

   // t1 & t2 are intersection (fractions along 'ray')
   //   negative means "before" the ray origin (in relation to the ray direction).

   // if ray started outside the cone and both intersections are "behind"
   //  -> the ray missed completely  (direction is away from the cone)
	if(! startInside && t1 < 0 && t2 < 0)
		return false;

	// if(t1 < 0 && t2 > 0)
	// {
	// 	t1 = t2;
	// 	t2 = -1;
	// }

	// ensure t1 is before t2
	if(t1 > t2)
	{
		float tmp = t2;
		t2 = t1;
		t1 = tmp;
	}


	bool t1_valid = false;
	bool t2_valid = false;
	bool t1_testCap = false;
	bool t2_testCap = false;

	// calculate 'height' of point, in relation to the cone's axis and its radius
	//   negative height means it is on the "negative" side of the infinite cone (never useful)
	//   larger than radius means it is too far away, i.e. intersection with the cap should be tested.
	float h1 = -1;
	if(t1 >= 0)
	{
		result.p_enter = rayPoint(ray, t1);
		// check if it's within sphere; too far on the periphery, will be tested below
		h1 = dot(result.p_enter - cone.sphere.center, cone.axis);
		t1_valid = h1 >= 0 && h1 <= (cone.sphere.radius*cos(cone.angle) + 1e-4);
		t1_testCap = ! t1_valid;
	}
	else if(startInside)
	{
		// swap t1 & t2
		t1_valid = true;
		t1 = 0;
		result.p_enter = ray.start;
	}
	else
		t1_testCap = true;

	if(t2 >= 0)
	{
		result.p_exit = rayPoint(ray, t2);
		float h2 = dot(result.p_exit - cone.sphere.center, cone.axis);
		t2_valid = h2 >= 0 && h2 <= (cone.sphere.radius*cos(cone.angle) + 1e-4);
		t2_testCap = ! t2_valid;

		// if t1 wasn't valid (but positive), test the cap for t1
		// t1_testCap = ! t1_valid && (h1 >= 0 || t1 == -1);
	}
	else
		t2_testCap = true;

	if(! t1_valid && ! t1_testCap && ! t2_valid && ! t2_testCap)
		return false; // there's no hope for an intersection

	if(t1_testCap || t2_testCap)
	{
		RayResult cap_result;
		if(testRaySphereCap(ray, cone, startInside, cap_result))
		{
			if(t1_testCap && cap_result.dist_enter >= 0)
			{
				t1 = cap_result.dist_enter;
				result.p_enter = cap_result.p_enter;
				t1_valid = true;
			}
			if(t2_testCap)
			{
				if(cap_result.dist_exit >= 0)
				{
					t2 = cap_result.dist_exit;
					result.p_exit = cap_result.p_exit;
					t2_valid = true;
				}
				else if(!t1_testCap && cap_result.dist_enter >= 0)
				{
					t2 = cap_result.dist_enter;
					result.p_exit = cap_result.p_enter;
					t2_valid = true;
				}
			}
			if(t1 >= 0 && t2 >= 0 && t2 < t1)
			{
				// swap t1 & t2
				float tmp = t2;
				t2 = t1;
				t1 = tmp;
				// swap p_enter & p_exit
				vec3 ptmp = result.p_enter;
				result.p_enter = result.p_exit;
				result.p_exit = ptmp;
			}
		}
		else
		{
			if(t1_testCap)
			{
				t1 = -1;
				t1_valid = false;
			}
			if(t2_testCap)
			{
				t2 = -1;
				t2_valid = false;
			}
		}
	}

	// neither of the intersections were valid, in the end
	if(! t1_valid && ! t2_valid)
		return false;

	if(t1_valid && t1 >= 0)
		result.dist_enter = t1;
	else
		result.dist_enter = -1;

	if(t2_valid && t2 >= 0)
		result.dist_exit = t2;
	else
		result.dist_exit = -1;

	// float ray_closest;
	// result.dist_center = rayPointDistance(ray, cone.sphere.center, ray_closest);
	// Ray spot_ray;
	// spot_ray.start = cone.sphere.center;
	// spot_ray.direction = cone.axis;
	// RayResult axis_result;
	// rayRayDistance(ray, spot_ray, axis_result);
	// vec3 p_closest = axis_result.p_enter;  // point on ray that is closest to spot axis
	// result.dist_axis = vectorVectorAngle(cone.axis, normalize(p_closest - cone.sphere.center));
	// // 0 = right on the axis, 1 = as far away from the axis as possible (still inside the cone)
	// result.dist_axis = clamp(result.dist_axis / cone.angle, 0, 1);

	return true;
}

bool testRaySphereCap(Ray ray, SphericalCone cone, bool startInside, out RayResult result)
{
	// find the ray intersection with a spherical cap of a cone.

	// quadric equation coefficients
	vec3 oc = ray.start - cone.sphere.center;
	float A = 1;  // actually: dot(ray.dir, ray.dir)   but ray.dir is already unit length
	float B = 2 * dot(oc, ray.direction);
	float C = dot(oc, oc) - cone.sphere.radius*cone.sphere.radius;

	float t1 = -1;
	float t2 = -1;
	if(! solveRoots(A, B, C, t1, t2))
		return false;

	result.dist_enter = -1;
	result.dist_exit = -1;

	if(t1 > t2)
	{
		float tmp = t2;
		t2 = t1;
		t1 = tmp;
	}

	// check the angular condition
	bool gotPoint = false;
	if(t1 >= 0)
	{
		vec3 p = rayPoint(ray, t1);
		if(isPointInsideCone(p, cone))
		{
			result.dist_enter = t1;
			result.p_enter = p;
			gotPoint = true;
		}
	}
	else if(startInside)
	{
		t1 = 0;
		result.dist_enter = t1;
		result.p_enter = ray.start;
		gotPoint = true;
	}

	if(t2 >= 0)
	{
		vec3 p = rayPoint(ray, t2);
		if(isPointInsideCone(p, cone))
		{
			if(! gotPoint)
			{
				result.dist_enter = t2;
				result.p_enter = p;
			}
			else
			{
				result.dist_exit = t2;
				result.p_exit = p;
			}
			gotPoint = true;
		}
	}

	return gotPoint;
}

vec3 rayPoint(Ray ray, float fraction)
{
	return ray.start + ray.direction*fraction;
}

// from pbr_lighting.glh (slightly modified)
float getSquareFalloffAttenuation(float distance_sq, float light_radius_squared)
{
    // float distance_square = dot(pos_to_light, pos_to_light);
    float factor          = distance_sq / light_radius_squared;
    float smooth_factor   = max(1.0 - factor * factor, 0.0);

    return (smooth_factor * smooth_factor) / max(distance_sq, 1e-5);
}

float getSpotAngleAttenuation(vec3 to_light, vec3 spot_dir, float outer_angle, float inner_angle)
{
    // the scale and offset computations can be done CPU-side
    float cos_outer   = cos(outer_angle);
    float spot_scale  = 1.0 / max(cos(inner_angle) - cos_outer, 1e-5);
    float spot_offset = -cos_outer * spot_scale;

    float cd          = dot(-spot_dir, to_light);
    float attenuation = clamp(cd * spot_scale + spot_offset, 0.0, 1.0);

    return attenuation * attenuation;
}

bool isPointInsideCone(vec3 point, SphericalCone cone)
{
	//    point
	//   /
	//  C--------| axis
	//           ^ radius

	vec3 to_center = point - cone.sphere.center;
	float len_sq = dot(to_center, to_center);

	// outside the entire sphere?
	if(len_sq > (cone.sphere.radius*cone.sphere.radius + 1e-1))
		return false;

	// cos of the angle between the vector and the cone's axis
	float cos_theta = dot(to_center, cone.axis) / sqrt(len_sq);

	// compare with the cosine of the cone's half-angle (i.e. must be less than 90 degrees)
	// (larger cos value means sharper angle)
	return cos_theta >= cos(cone.angle);
}

// calculate shortest distance between two rays
void rayRayDistance(Ray ray1, Ray ray2, out RayResult result)
{
	vec3 d1 = ray1.direction;
	vec3 d2 = ray2.direction;

	vec3 w0 = ray1.start - ray2.start;

	float a = 1;//dot(d1, d1); // always 1 if d1 is normalized
	float b = dot(d1, d2);
	float c = 1;//dot(d2, d2); // always 1 if d2 is normalized
	float d = dot(d1, w0);
	float e = dot(d2, w0);

	float denominator = a * c - b * b;

	if(abs(denominator) > 1e-6)
	{
		// clamp to ensure they are non-negative (since it's a ray)
		result.dist_enter = max((b * e - c * d) / denominator, 0);
		result.dist_exit = max((a * e - b * d) / denominator, 0);
	}
	else // rays are parallel
	{
		result.dist_enter = 0;
		// project onto ray2's direction
		result.dist_exit = max(dot(d2, w0) / c, 0);
	}

	result.p_enter = rayPoint(ray1, result.dist_enter); // point on ray1
	result.p_exit = rayPoint(ray2, result.dist_exit);   // point on ray2
}

float rayPointDistance(Ray ray, vec3 point, out float ray_dist)
{
	// Vector from the ray origin to the point
	vec3 w = point - ray.start;

	// Project vector w onto the ray direction
	ray_dist = dot(w, ray.direction);

	if(ray_dist < 0.0)
 	{
	    // Closest point is the ray origin
	    vec3 p_closest = ray.start;
	    return length(point - p_closest);
	}

    // Closest point along the ray
    vec3 p_closest = rayPoint(ray, ray_dist);
    return length(point - p_closest);
}

float vectorVectorAngle(vec3 v1_norm, vec3 v2_norm)
{
	float cos_angle = clamp(dot(v1_norm, v2_norm), -1, 1);
	return acos(cos_angle);
}

bool solveRoots(float squareCoeff, float linearCoeff, float constantCoeff, out float t1, out float t2)
{
	float A = 2*squareCoeff;
	float B = linearCoeff;
	float C = constantCoeff;

	float discriminant = B*B - 2*A*C;
	if(discriminant < 0)
		return false;  // no real intersection

	// step 2: Solve the quadric equation
	float sqrt_discriminant = sqrt(discriminant);
	t1 = (-B - sqrt_discriminant) / A;
	t2 = (-B + sqrt_discriminant) / A;

	return true;
}
