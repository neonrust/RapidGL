#version 460 core
#include "shared.h"

// TODO: search only in the active clusters

layout(std430, binding = CLUSTERS_SSBO_BINDING_INDEX) buffer ClustersSSBO
{
	ClusterAABB clusters[];
};

layout (std430, binding = POINT_LIGHTS_SSBO_BINDING_INDEX) buffer PointLightsSSBO
{
    PointLight point_lights[];
};

layout (std430, binding = LIGHT_INDEX_LIST_SSBO_BINDING_INDEX) buffer LightIndexListSSBO
{
    uint global_light_index_list[];
};

layout (std430, binding = LIGHT_GRID_SSBO_BINDING_INDEX) buffer LightGridSSBO
{
	uint global_index_count;
    LightGrid light_grid[];
};

uniform mat4 u_view_matrix;

shared uint s_cluster_index_1D;
shared ClusterAABB s_cluster_aabb;

shared uint s_point_lights_count;
shared uint s_point_lights_start_offset;
shared uint s_point_lights_list[1024];

bool sphereInsideAABB(vec3 center, float radius, ClusterAABB aabb);
float sqDistancePointAABB(vec3 point, ClusterAABB aabb);

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint index = 0;

	if (gl_LocalInvocationIndex == 0)
	{
		s_point_lights_count = 0;

		s_cluster_index_1D = gl_WorkGroupID.x;//unique_clusters[gl_WorkGroupID.x]; // TODO: must have!!
		s_cluster_aabb     = clusters[s_cluster_index_1D];
	}
	barrier();

    const uint THREADS_COUNT = gl_WorkGroupSize.x;

	// Intersect point lights against AABBs.
    for (uint i = gl_LocalInvocationIndex; i < point_lights.length(); i += THREADS_COUNT)
	{
		PointLight light = point_lights[i];

		if (sphereInsideAABB(light.position, light.radius, s_cluster_aabb))
		{
			index = atomicAdd(s_point_lights_count, 1);

			if (index < 1024)
			{
				s_point_lights_list[index] = i;
			}
		}
    }

	// TODO: Intersect spot lights against AABBs

    // We want all thread groups to have completed the light tests before continuing.
	barrier();

	// Update the global light grids with the light lists and light counts.
	if (gl_LocalInvocationIndex == 0)
	{
		// Update light grid for point lights.
		s_point_lights_start_offset = atomicAdd(global_index_count, s_point_lights_count);
		light_grid[s_cluster_index_1D].offset = s_point_lights_start_offset;
		light_grid[s_cluster_index_1D].count  = s_point_lights_count;
	}
	barrier();

	// Update the global light index lists with the shared light lists.
	for (uint i = gl_LocalInvocationIndex; i < s_point_lights_count; i += THREADS_COUNT)
	{
		global_light_index_list[s_point_lights_start_offset + i] = s_point_lights_list[i];
	}
}

bool sphereInsideAABB(vec3 center, float radius, ClusterAABB aabb)
{
	center = vec3(u_view_matrix * vec4(center, 1.0));
    float squared_distance = sqDistancePointAABB(center, aabb);

    return squared_distance <= (radius * radius);
}

float sqDistancePointAABB(vec3 point, ClusterAABB aabb)
{
    float sq_dist = 0.0;
    
	for (int i = 0; i < 3; ++i)
	{
        float v = point[i];
        
		if (v < aabb.min[i]) sq_dist += pow(aabb.min[i] - v, 2);
        if (v > aabb.max[i]) sq_dist += pow(v - aabb.max[i], 2);
    }

    return sq_dist;
}