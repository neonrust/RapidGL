#version 460 core
#include "shared-structs.glh"

layout(std430, binding = SSBO_BIND_CLUSTER_AABB) readonly buffer ClusterAABBSSBO
{
	AABB cluster_aabb[];
};

layout(std430, binding = SSBO_BIND_CLUSTER_LIGHTS) buffer ClusterLightsSSBO
{
	ClusterLights cluster_lights[];
};

layout(std430, binding = SSBO_BIND_LIGHTS) readonly buffer LightsSSBO
{
	GPULight lights[];
};

// layout(std140, binding = UBO_BIND_LIGHT_COUNTS) uniform LightCountersUBO
// {
// 	LightCounts light_counts;
// };

layout(std430, binding = SSBO_BIND_CLUSTER_DISCOVERY) readonly buffer ClusterDiscoverySSBO
{
	uint num_active;
	uint nonempty_clusters[];      // size = range * 2
	//  range = u_num_clusters
	//    nonempty 0 - range-1
	//    active   range - 2*range-1
};

uniform mat4 u_view_matrix;
uniform uint u_num_clusters;
uniform uint u_max_cluster_avg_lights;


shared uint s_cluster_index;
shared AABB s_cluster_aabb;

const uint cluster_max_lights = CLUSTER_MAX_POINT_LIGHTS + CLUSTER_MAX_SPOT_LIGHTS + CLUSTER_MAX_AREA_LIGHTS;

shared uint s_light_count;
shared uint s_light_list[cluster_max_lights];

// shared uint s_point_lights_count;
// shared uint s_point_lights_list[CLUSTER_MAX_POINT_LIGHTS];

// shared uint s_spot_lights_count;
// shared uint s_spot_lights_list[CLUSTER_MAX_SPOT_LIGHTS];

// shared uint s_area_lights_count;
// shared uint s_area_lights_list[CLUSTER_MAX_AREA_LIGHTS];

bool sphereInsideAABB(vec3 center, float radius, AABB aabb);
float sqDistancePointAABB(vec3 point, AABB aabb);

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
void main()
{
    if (gl_LocalInvocationIndex == 0) // once per cluster
    {
	    uint active_offset = u_num_clusters;
	    s_cluster_index = nonempty_clusters[gl_WorkGroupID.x + active_offset];
	    s_cluster_aabb = cluster_aabb[s_cluster_index];

		s_light_count = 0;
    }
    barrier();

    const uint THREADS_COUNT = gl_WorkGroupSize.x;

    // Intersect all lights against cluster AABB
    for (uint light_index = gl_LocalInvocationIndex; light_index < lights.length(); light_index += THREADS_COUNT)
    {
    	GPULight light = lights[light_index];

     	if(light.intensity < 1e-1)
      		continue;

		vec3 sphere_center;
		float sphere_radius = 0;   // if still 0 the below switch did not wrk

		uint light_type = light.type_flags & LIGHT_TYPE_MASK;

     	switch(light_type)
      	{
			case LIGHT_TYPE_POINT:
			{
				sphere_center = light.position;
				sphere_radius = light.radius;
			}
			break;

			case LIGHT_TYPE_SPOT:
			{
	         	sphere_center = light.position;
				sphere_radius = light.radius;
				// use minimal sphere bounds, if set
	        	if(light.spot_bounds_radius > 0)
	   			{
			  		sphere_radius = light.spot_bounds_radius;
			    	sphere_center = light.position + light.direction*sphere_radius;
				}
			}
			break;

			case LIGHT_TYPE_AREA:
			{
				// center from average of two diagonal points
	            sphere_center = (light.area_points[1].xyz + light.area_points[2].xyz) / 2;
	            // approximation of the light radius
	            sphere_radius = 50 * light.intensity * distance(sphere_center, light.area_points[1].xyz);
			}
			break;
		}

		bool affecting = light_type == LIGHT_TYPE_DIRECTIONAL \
			|| (sphere_radius > 0 && sphereInsideAABB(sphere_center, sphere_radius, s_cluster_aabb));
		if(affecting)
		{
			uint next_index = atomicAdd(s_light_count, 1);

			if (next_index < cluster_max_lights)
				s_light_list[next_index] = light_index;
		}
    }

    // Wait for all threads (for this cluster) to complete the light tests
    barrier();

    if (gl_LocalInvocationIndex == 0)
    {
	    // Update the cluster's light list with the collected lights
		ClusterLights cluster = cluster_lights[s_cluster_index];

     	cluster.num_lights = s_light_count;

		for(uint idx = 0; idx < cluster.num_lights; ++idx)
			cluster.light_index[idx] = s_light_list[idx];

		cluster_lights[s_cluster_index] = cluster;
	}
}

bool sphereInsideAABB(vec3 center, float radius, AABB aabb)
{
    center = vec3(u_view_matrix * vec4(center, 1.0));
    float squared_distance = sqDistancePointAABB(center, aabb);

    return squared_distance <= (radius * radius);
}

float sqDistancePointAABB(vec3 point, AABB aabb)
{
    float sq_dist = 0.0;

    for (int i = 0; i < 3; ++i)
    {
        float v = point[i];

        if (v < aabb.min[i]) sq_dist += pow(aabb.min[i] - v, 2);
        if (v > aabb.max[i]) sq_dist += pow(v - aabb.max[i], 2);
    }

    return sq_dist;
}
