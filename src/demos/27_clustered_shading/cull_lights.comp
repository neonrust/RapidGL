#version 460 core

// TODO: search only in the active clusters

struct PointLight
{
    vec4  position;
    vec4  color;
    float intensity;
    float range;
	uint  pad0;
	uint  pad1;
};

struct LightGrid
{
    uint offset;
    uint count;
};

struct ClusterAABB
{
	vec4 min_point;
	vec4 max_point;
};

layout(std430, binding = 0) buffer ClustersSSBO
{
	ClusterAABB clusters[];
};

layout (std430, binding = 1) buffer LightSSBO
{
    PointLight point_lights[];
};

layout (std430, binding = 2) buffer LightIndexSSBO
{
    uint global_light_index_list[];
};

layout (std430, binding = 3) buffer LightGridSSBO
{
	uint global_index_count;
    LightGrid light_grid[];
};

shared PointLight shared_point_lights[16*9*4];

uniform mat4  u_view_matrix;
uniform mat4  u_inverse_projection;
uniform uvec4 u_tile_sizes;
uniform uvec2 u_screen_dimensions;

bool  testSphereAABB (uint light, uint tile);
float sqDistPointAABB(vec3 point, uint tile);

layout(local_size_x = 16, local_size_y = 9, local_size_z = 4) in;
void main()
{
    global_index_count = 0;
    uint threads_count = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
    uint lights_count  = point_lights.length();
    uint num_batches   = (lights_count + threads_count -1) / threads_count;

    uint tile_index = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;
    
    uint visible_lights_count = 0;
    uint visible_lights_indices[100];

    for (uint batch = 0; batch < num_batches; ++batch)
	{
        uint light_index = batch * threads_count + gl_LocalInvocationIndex;

        // Prevent overflow by clamping to last light which is always null
        light_index = min(light_index, lights_count);

        // Populating shared light array
        shared_point_lights[gl_LocalInvocationIndex] = point_lights[light_index];
        barrier();

        // Iterating within the current batch of lights
        for (uint light = 0; light < threads_count; ++light)
		{
			if (testSphereAABB(light, tile_index))
			{
			    visible_lights_indices[visible_lights_count] = batch * threads_count + light;
			    visible_lights_count += 1;
			}
        }
    }

    // We want all thread groups to have completed the light tests before continuing
    barrier();

    uint offset = atomicAdd(global_index_count, visible_lights_count);

    for(uint i = 0; i < visible_lights_count; ++i)
	{
        global_light_index_list[offset + i] = visible_lights_indices[i];
    }

    light_grid[tile_index].offset = offset;
    light_grid[tile_index].count  = visible_lights_count;
}

bool testSphereAABB(uint light, uint tile)
{
    float radius           = shared_point_lights[light].range;
    vec3  center           = vec3(u_view_matrix * shared_point_lights[light].position);
    float squared_distance = sqDistPointAABB(center, tile);

    return squared_distance <= (radius * radius);
}

float sqDistPointAABB(vec3 point, uint tile)
{
    float       sq_dist         = 0.0;
    ClusterAABB current_cell    = clusters[tile];
    clusters[tile].max_point[3] = tile;
    
	for (int i = 0; i < 3; ++i)
	{
        float v = point[i];
        if (v < current_cell.min_point[i])
		{
            sq_dist += (current_cell.min_point[i] - v) * (current_cell.min_point[i] - v);
        }
        if(v > current_cell.max_point[i])
		{
            sq_dist += (v - current_cell.max_point[i]) * (v - current_cell.max_point[i]);
        }
    }
    return sq_dist;
}