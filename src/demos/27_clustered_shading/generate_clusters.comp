#version 460 core

struct ClusterAABB
{
	vec4 minPoint;
	vec4 maxPoint;
};

// ssbo
layout(std430, binding = 0) buffer clustersSSBO
{
	ClusterAABB clusters[];
};

// uniforms
uniform float zNear;
uniform float zFar;
uniform vec2 clusterSize;
uniform vec2 viewPxSize;
uniform uvec3 gridDim;
uniform mat4 inverseProjection;

/* Function prototypes */
uvec3 computeClusterIndex3D(uint clusterIndex1D);
vec4 clipToView(vec4 clip);
vec4 screenToView(vec4 screen);
vec3 lineIntersectionToZPlane(vec3 A, vec3 B, float zDistance);

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint  clusterIndex1D = gl_GlobalInvocationID.x;
	uvec3 clusterIndex3D = computeClusterIndex3D(clusterIndex1D);

	vec4 minPointSS = vec4( clusterIndex3D.xy      * clusterSize, -1.0, 1.0); // Top left in screen space
	vec4 maxPointSS = vec4((clusterIndex3D.xy + 1) * clusterSize, -1.0, 1.0); // Bottom right in screen space

	vec3 minPointVS = screenToView(minPointSS).xyz; // Top left in screen space
	vec3 maxPointVS = screenToView(maxPointSS).xyz; // Bottom right in screen space

	// Near and far values of the cluster in view space
	float clusterZNear = zNear * pow(zFar / zNear, float(clusterIndex3D.z)     / float(gridDim.z));
	float clusterZFar  = zNear * pow(zFar / zNear, float(clusterIndex3D.z + 1) / float(gridDim.z));

	// Eye pos in view space is at the origin
	vec3 eyePos       = vec3(0.0);

	vec3 minPointNear = lineIntersectionToZPlane(eyePos, minPointVS, clusterZNear);
	vec3 minPointFar  = lineIntersectionToZPlane(eyePos, minPointVS, clusterZFar);
	vec3 maxPointNear = lineIntersectionToZPlane(eyePos, maxPointVS, clusterZNear);
	vec3 maxPointFar  = lineIntersectionToZPlane(eyePos, maxPointVS, clusterZFar);

	vec3 minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
	vec3 maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

	clusters[clusterIndex1D].minPoint = vec4(minPointAABB, 1.0);
	clusters[clusterIndex1D].maxPoint = vec4(maxPointAABB, 1.0);
}

uvec3 computeClusterIndex3D(uint clusterIndex1D)
{
	uint x = clusterIndex1D % gridDim.x;
	uint y = clusterIndex1D % (gridDim.x * gridDim.y) / gridDim.x;
	uint z = clusterIndex1D / (gridDim.x * gridDim.y);

	return uvec3(x, y, z);
}

// Creates a line from the eye to the screenpoint, then finds its intersection
// With a z oriented plane located at the given distance to the origin
vec3 lineIntersectionToZPlane(vec3 A, vec3 B, float zDistance)
{
    //Because this is a Z based normal this is fixed
    vec3 normal = vec3(0.0, 0.0, 1.0);

    vec3 ab = B - A;

    //Computing the intersection length for the line and the plane
    float t = (zDistance - dot(normal, A)) / dot(normal, ab);

	bool intersect = (t >= 0.0 && t <= 1.0);

    //Computing the actual xyz position of the point along the line
	vec3 result = vec3(0);
    if (intersect)
	{
		result = A + t * ab;
	}
	
    return result;
}

vec4 clipToView(vec4 clip)
{
    //View space transform
    vec4 view = inverseProjection * clip;

    //Perspective projection
    view = view / view.w;
    
    return view;
}

vec4 screenToView(vec4 screen)
{
    //Convert to NDC
    vec2 texCoord = screen.xy * viewPxSize.xy;

    //Convert to clipSpace
    vec4 clip = vec4(vec2(texCoord.x, 1.0 - texCoord.y) * 2.0 - 1.0, screen.z, screen.w);
    // vec4 clip = vec4(vec2(texCoord.x, texCoord.y) * 2.0 - 1.0, screen.z, screen.w);

    return clipToView(clip);
}