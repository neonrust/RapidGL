#version 460 core
#include "shared.h"

layout(std430, binding = CLUSTERS_SSBO_BINDING_INDEX) buffer ClustersSSBO
{
	ClusterAABB clusters[];
};

// uniforms
uniform float u_near_z;
uniform float u_far_z;
uniform vec2  u_cluster_size;
uniform vec2  u_view_px_size;
uniform uvec3 u_grid_dim;
uniform mat4  u_inverse_projection;

/* Functions' prototypes */
uvec3 computeClusterIndex3D(uint cluster_index1D);
vec4 clipToView(vec4 clip);
vec4 screenToView(vec4 screen);
vec3 lineIntersectionToZPlane(vec3 A, vec3 B, float z_distance);

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;
void main()
{
	uint  cluster_index1D = gl_GlobalInvocationID.x;
	uvec3 cluster_index3D = computeClusterIndex3D(cluster_index1D);

	vec4 min_point_ss = vec4( cluster_index3D.xy      * u_cluster_size, -1.0, 1.0); // Top left in screen space
	vec4 max_point_ss = vec4((cluster_index3D.xy + 1) * u_cluster_size, -1.0, 1.0); // Bottom right in screen space

	vec3 min_point_vs = screenToView(min_point_ss).xyz; // Top left in screen space
	vec3 max_point_vs = screenToView(max_point_ss).xyz; // Bottom right in screen space

	// Near and far values of the cluster in view space
	float cluster_near_z = -u_near_z * pow(u_far_z / u_near_z, float(cluster_index3D.z)     / float(u_grid_dim.z));
	float cluster_far_z  = -u_near_z * pow(u_far_z / u_near_z, float(cluster_index3D.z + 1) / float(u_grid_dim.z));

	// Eye pos in view space is at the origin
	vec3 eye_pos = vec3(0.0);

	vec3 min_point_near = lineIntersectionToZPlane(eye_pos, min_point_vs, cluster_near_z);
	vec3 min_point_far  = lineIntersectionToZPlane(eye_pos, min_point_vs, cluster_far_z);
	vec3 max_point_near = lineIntersectionToZPlane(eye_pos, max_point_vs, cluster_near_z);
	vec3 max_point_far  = lineIntersectionToZPlane(eye_pos, max_point_vs, cluster_far_z);

	vec3 min_point_AABB = min(min(min_point_near, min_point_far), min(max_point_near, max_point_far));
	vec3 max_point_AABB = max(max(min_point_near, min_point_far), max(max_point_near, max_point_far));

	clusters[cluster_index1D].min_point = vec4(min_point_AABB, 0.0);
	clusters[cluster_index1D].max_point = vec4(max_point_AABB, 0.0);
}

uvec3 computeClusterIndex3D(uint cluster_index1D)
{
	uint x = cluster_index1D % u_grid_dim.x;
	uint y = cluster_index1D % (u_grid_dim.x * u_grid_dim.y) / u_grid_dim.x;
	uint z = cluster_index1D / (u_grid_dim.x * u_grid_dim.y);

	return uvec3(x, y, z);
}

// Creates a line from the eye to the screenpoint, then finds its intersection
// With a z oriented plane located at the given distance to the origin
vec3 lineIntersectionToZPlane(vec3 A, vec3 B, float zDistance)
{
    //Because this is a Z based normal this is fixed
//    vec3 normal = vec3(0.0, 0.0, 1.0);
//
//    vec3 ab = B - A;
//
//    //Computing the intersection length for the line and the plane
//    float t = (zDistance - dot(normal, A)) / dot(normal, ab);
//
//	bool intersect = (t >= 0.0 && t <= 1.0);
//
//    //Computing the actual xyz position of the point along the line
//	vec3 result = vec3(0, 0, 1);
//    if (intersect)
//	{
//		result = A + t * ab;
//	}
//	
//    return result;
    //Because this is a Z based normal this is fixed
    vec3 normal = vec3(0.0, 0.0, 1.0);

    vec3 ab =  B - A;

    //Computing the intersection length for the line and the plane
    float t = (zDistance - dot(normal, A)) / (dot(normal, ab));

    //Computing the actual xyz position of the point along the line
    vec3 result = A + t * ab;

    return result;
}

vec4 clipToView(vec4 clip)
{
    //View space transform
    vec4 view = u_inverse_projection * clip;

    //Perspective projection
    view = view / view.w;
    
    return view;
}

vec4 screenToView(vec4 screen)
{
    //Convert to NDC
    vec2 texcoord = screen.xy * u_view_px_size.xy;

    //Convert to clipSpace
    vec4 clip = vec4(vec2(texcoord.x, texcoord.y) * 2.0 - 1.0, screen.z, screen.w);

    return clipToView(clip);
}